<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Nebula</title>
    <style>
        /* --- Basic CSS Reset and Styling --- */
        body {
            margin: 0;
            overflow: hidden;
            /* A deep, dark space-like background */
            background-color: #000005;
            font-family: 'Inter', sans-serif;
            color: white;
            cursor: none; /* Hide the default cursor, we'll use a custom one */
        }

        /* --- Canvas Styling --- */
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1; /* Place canvas behind other content */
        }

        /* --- UI & Text Overlay Styling --- */
        .overlay {
            position: absolute;
            top: 2rem;
            left: 2rem;
            right: 2rem;
            text-align: left;
            pointer-events: none; /* Allow mouse events to pass through to the canvas */
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin: 0;
            letter-spacing: 2px;
            opacity: 0.8;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        p {
            font-size: 1rem;
            font-weight: 300;
            margin-top: 0.5rem;
            max-width: 400px;
            opacity: 0.7;
            line-height: 1.5;
        }

        /* --- Custom Cursor Styling --- */
        .cursor-dot {
            width: 8px;
            height: 8px;
            background-color: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 10000;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 25px rgba(0, 255, 255, 0.5);
            transition: transform 0.1s ease-out, background-color 0.2s ease, box-shadow 0.2s ease;
        }
        
        body.dragging .cursor-dot {
            transform: translate(-50%, -50%) scale(2);
            background-color: rgba(255, 100, 100, 0.9);
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.8), 0 0 35px rgba(255, 100, 100, 0.6);
        }


        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }
            p {
                font-size: 0.9rem;
            }
            .overlay {
                top: 1.5rem;
                left: 1.5rem;
                right: 1.5rem;
            }
        }
    </style>
    <!-- Google Fonts for a clean, modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300&display=swap" rel="stylesheet">
</head>
<body>
    <!-- The canvas element where the Three.js scene will be rendered -->
    <canvas id="webgl-canvas"></canvas>

    <!-- Simple overlay for title and instructions -->
    <div class="overlay">
        <h1>Stellar Flow</h1>
        <p>Move your cursor to warp the nebula. Click to create a ripple. Click and drag to form a vortex.</p>
    </div>

    <!-- Custom cursor element -->
    <div class="cursor-dot"></div>

    <!-- 
      Using an import map for Three.js. This is a modern approach to handle modules
      directly from a CDN without needing a build step.
    -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // --- Import necessary modules from Three.js ---
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Scene Setup ---
        let scene, camera, renderer, composer, particles;
        const PARTICLE_COUNT = 50000; // Number of particles in the simulation

        // --- Interaction State ---
        let mouse = new THREE.Vector2(0, 0);
        let isMouseDown = false;
        let clickEffect = {
            position: new THREE.Vector2(),
            strength: 0,
            maxStrength: 0.8,
            decay: 0.95 
        };

        // --- Noise function for organic movement (unchanged) ---
        const F3 = 1.0 / 3.0;
        const G3 = 1.0 / 6.0;
        const perm = new Uint8Array(512);
        for (let i = 0; i < 512; i++) perm[i] = Math.floor(Math.random() * 256);

        function grad3(i, x, y, z) {
            const h = i & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        function noise3D(x, y, z) {
            let n0, n1, n2, n3;
            const s = (x + y + z) * F3;
            const i = Math.floor(x + s);
            const j = Math.floor(y + s);
            const k = Math.floor(z + s);
            const t = (i + j + k) * G3;
            const X0 = i - t;
            const Y0 = j - t;
            const Z0 = k - t;
            const x0 = x - X0;
            const y0 = y - Y0;
            const z0 = z - Z0;

            let i1, j1, k1;
            let i2, j2, k2;

            if (x0 >= y0) {
                if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
            } else {
                if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
            }

            const x1 = x0 - i1 + G3;
            const y1 = y0 - j1 + G3;
            const z1 = z0 - k1 + G3;
            const x2 = x0 - i2 + 2.0 * G3;
            const y2 = y0 - j2 + 2.0 * G3;
            const z2 = z0 - k2 + 2.0 * G3;
            const x3 = x0 - 1.0 + 3.0 * G3;
            const y3 = y0 - 1.0 + 3.0 * G3;
            const z3 = z0 - 1.0 + 3.0 * G3;

            const ii = i & 255;
            const jj = j & 255;
            const kk = k & 255;

            let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
            if (t0 < 0) n0 = 0.0;
            else { t0 *= t0; n0 = t0 * t0 * grad3(perm[ii + perm[jj + perm[kk]]], x0, y0, z0); }

            let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
            if (t1 < 0) n1 = 0.0;
            else { t1 *= t1; n1 = t1 * t1 * grad3(perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]], x1, y1, z1); }

            let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
            if (t2 < 0) n2 = 0.0;
            else { t2 *= t2; n2 = t2 * t2 * grad3(perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]], x2, y2, z2); }

            let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
            if (t3 < 0) n3 = 0.0;
            else { t3 *= t3; n3 = t3 * t3 * grad3(perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]], x3, y3, z3); }

            return 32.0 * (n0 + n1 + n2 + n3);
        }


        // --- Initialization Function ---
        function init() {
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3;

            // Scene setup
            scene = new THREE.Scene();

            // Particle geometry and material
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const originalPositions = new Float32Array(PARTICLE_COUNT * 3); 

            const color = new THREE.Color();
            const radius = 2;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;

                color.setHSL(0.5 + 0.2 * (i / PARTICLE_COUNT), 0.7, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('originalPosition', new THREE.BufferAttribute(originalPositions, 3));

            const material = new THREE.PointsMaterial({
                size: 0.005,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Renderer setup
            const canvas = document.getElementById('webgl-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Post-processing for bloom effect
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseDown(event) {
            isMouseDown = true;
            document.body.classList.add('dragging');
        }

        function onMouseUp(event) {
            isMouseDown = false;
            clickEffect.position.copy(mouse);
            clickEffect.strength = clickEffect.maxStrength; // Trigger the click ripple
            document.body.classList.remove('dragging');
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.0002;
            const positions = particles.geometry.attributes.position.array;
            const originalPositions = particles.geometry.attributes.originalPosition.array;

            // Decay the click effect strength over time
            if (clickEffect.strength > 0) {
                clickEffect.strength *= clickEffect.decay;
                if (clickEffect.strength < 0.01) {
                    clickEffect.strength = 0;
                }
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const ox = originalPositions[ix];
                const oy = originalPositions[iy];
                const oz = originalPositions[iz];

                // 1. Base organic movement using noise
                const noiseFactor = 0.1;
                const displacementX = noise3D(ox * 0.5 + time, oy * 0.5, oz * 0.5) * noiseFactor;
                const displacementY = noise3D(ox * 0.5, oy * 0.5 + time, oz * 0.5) * noiseFactor;
                const displacementZ = noise3D(ox * 0.5, oy * 0.5, oz * 0.5 + time) * noiseFactor;

                let finalX = ox + displacementX;
                let finalY = oy + displacementY;
                let finalZ = oz + displacementZ;

                // 2. Apply forces from interactions
                const mouseWorldX = mouse.x * (window.innerWidth / window.innerHeight) * 1.5;
                const mouseWorldY = mouse.y * 1.5;

                // --- DRAG / VORTEX INTERACTION ---
                if (isMouseDown) {
                    const dragDistance = Math.sqrt(Math.pow(finalX - mouseWorldX, 2) + Math.pow(finalY - mouseWorldY, 2));
                    const dragForce = Math.max(0, 1 - dragDistance * 1.2) * 0.1;
                    if (dragForce > 0) {
                        finalX += (mouseWorldX - finalX) * dragForce;
                        finalY += (mouseWorldY - finalY) * dragForce;
                    }
                } 
                // --- HOVER INTERACTION ---
                else {
                    const hoverDistance = Math.sqrt(Math.pow(ox - mouseWorldX, 2) + Math.pow(oy - mouseWorldY, 2));
                    const hoverForce = Math.max(0, 1 - hoverDistance * 1.5) * 0.5;
                    finalX += (ox - mouseWorldX) * hoverForce;
                    finalY += (oy - mouseWorldY) * hoverForce;
                }

                // --- CLICK / RIPPLE INTERACTION ---
                if (clickEffect.strength > 0) {
                    const clickWorldX = clickEffect.position.x * (window.innerWidth / window.innerHeight) * 1.5;
                    const clickWorldY = clickEffect.position.y * 1.5;
                    const clickDistance = Math.sqrt(Math.pow(ox - clickWorldX, 2) + Math.pow(oy - clickWorldY, 2));
                    const rippleFalloff = Math.max(0, 1 - clickDistance * 1.8);
                    const rippleForce = Math.sin(rippleFalloff * Math.PI) * clickEffect.strength;
                    
                    if (rippleForce > 0) {
                         const angle = Math.atan2(oy - clickWorldY, ox - clickWorldX);
                         finalX += Math.cos(angle) * rippleForce;
                         finalY += Math.sin(angle) * rippleForce;
                    }
                }

                positions[ix] = finalX;
                positions[iy] = finalY;
                positions[iz] = finalZ;
            }

            particles.geometry.attributes.position.needsUpdate = true;

            camera.position.x = Math.sin(time * 0.5) * 0.5;
            camera.position.y = Math.cos(time * 0.3) * 0.5;
            camera.lookAt(scene.position);

            composer.render();
        }
        
        // --- Custom Cursor Logic ---
        const cursorDot = document.querySelector('.cursor-dot');
        document.addEventListener('mousemove', (e) => {
            cursorDot.style.left = `${e.clientX}px`;
            cursorDot.style.top = `${e.clientY}px`;
        });

        // --- Start the application ---
        init();
        animate();

    </script>
</body>
</html>
