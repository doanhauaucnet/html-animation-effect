<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aurora Particle Garden</title>
<style>
  :root{
    --bg:#070b12;
    --fg:#e6f1ff;
    --muted:#a3b3c6;
    --glow: 0 0 40px rgba(130,200,255,.35), 0 0 120px rgba(80,180,255,.2);
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body{
    margin:0;
    background: radial-gradient(1200px 800px at 20% 10%, #0b1220 0%, #070b12 50%, #05070e 100%);
    color:var(--fg);
    overflow:hidden;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue",
                 "Noto Sans", "Liberation Sans", Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  /* Canvas backdrop */
  #scene{
    position:fixed; inset:0; width:100vw; height:100vh; display:block;
    filter: saturate(1.15) contrast(1.05);
  }

  /* Layered aurora ribbons (pure CSS) */
  .aurora{
    position:fixed; inset:-10vmax;
    filter: blur(70px) saturate(120%);
    mix-blend-mode: screen;
    pointer-events:none;
  }
  .aurora::before, .aurora::after{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(60% 120% at 20% 30%, rgba(0,180,255,.28), rgba(0,0,0,0) 60%),
      radial-gradient(70% 140% at 80% 70%, rgba(120,0,255,.22), rgba(0,0,0,0) 65%),
      conic-gradient(from 0deg at 50% 50%,
        rgba(0,255,180,.18), rgba(0,160,255,.12), rgba(200,0,255,.14), rgba(0,255,180,.18));
    animation: drift 32s linear infinite;
    transform: translateZ(0);
    opacity:.9;
  }
  .aurora::after{
    filter: hue-rotate(40deg) brightness(1.15);
    animation: drift2 46s linear infinite;
    opacity:.8;
  }
  @keyframes drift{
    0%{ transform: translate(-4%, -2%) rotate(0deg) scale(1.05); }
    50%{ transform: translate(3%, 2%) rotate(180deg) scale(1.1); }
    100%{ transform: translate(-4%, -2%) rotate(360deg) scale(1.05); }
  }
  @keyframes drift2{
    0%{ transform: translate(2%, 4%) rotate(0deg) scale(1.1); }
    50%{ transform: translate(-3%, -1%) rotate(-180deg) scale(1.05); }
    100%{ transform: translate(2%, 4%) rotate(-360deg) scale(1.1); }
  }

  /* Floating gradient orbs (positions updated by JS) */
  .orbs{ position:fixed; inset:0; pointer-events:none; mix-blend-mode:screen; }
  .orb{
    position:absolute; width:38vmax; height:38vmax; border-radius:50%;
    background: radial-gradient(circle at 30% 30%,
      rgba(255,255,255,.7), rgba(255,255,255,.0) 40%),
      radial-gradient(circle at 60% 60%,
      rgba(0,200,255,.6), rgba(0,0,0,0) 60%),
      radial-gradient(circle at 40% 70%,
      rgba(190,0,255,.45), rgba(0,0,0,0) 65%);
    filter: blur(35px);
    transform: translate(-50%, -50%) scale(1);
    opacity:.35;
  }

  /* Title card */
  .hud{
    position:fixed; inset:0; display:grid; place-items:center; pointer-events:none;
  }
  .title{
    text-align:center; line-height:1.1;
    text-shadow:
      0 2px 40px rgba(0,180,255,.25),
      0 0 1px rgba(255,255,255,.4);
    transform: translateZ(0);
    will-change: transform;
  }
  .title h1{
    margin:0;
    font-weight:800;
    letter-spacing:.02em;
    font-size: clamp(2.4rem, 6vw + 1rem, 7rem);
  }
  .title p{
    margin:.8rem 0 0;
    color:var(--muted);
    font-size: clamp(.9rem, 1.2vw + .4rem, 1.25rem);
  }

  /* Controls badge */
  .badge{
    position:fixed; bottom:1rem; right:1rem; z-index:10;
    font-size:.85rem; color:#cfe7ff; background: rgba(8,14,26,.6);
    border:1px solid rgba(130,180,255,.25);
    backdrop-filter: blur(8px);
    padding:.65rem .8rem; border-radius:14px; box-shadow: var(--glow);
    user-select:none; pointer-events:auto;
  }
  .badge kbd{
    display:inline-block; border:1px solid rgba(180,210,255,.35); border-bottom-width:2px;
    border-radius:8px; padding:.1rem .35rem; margin:0 .2rem; font-weight:700; color:#eaf4ff;
    background: linear-gradient(180deg, rgba(35,50,80,.65), rgba(20,32,58,.65));
  }

  /* Subtle vignette */
  .vignette{
    position:fixed; inset:0; pointer-events:none;
    background: radial-gradient(120vh 120vh at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,.25) 100%);
  }
</style>
</head>
<body>
  <canvas id="scene"></canvas>
  <div class="aurora"></div>
  <div class="orbs">
    <div class="orb" id="orbA"></div>
    <div class="orb" id="orbB"></div>
    <div class="orb" id="orbC"></div>
  </div>

  <div class="hud">
    <div class="title" id="title">
      <h1>Aurora Particle Garden</h1>
      <p>Move the mouse • <em>Particles follow the glow</em></p>
    </div>
  </div>

  <div class="badge">Controls:
    <kbd>R</kbd> Reset •
    <kbd>Space</kbd> Attract/Repel •
    <kbd>B</kbd> Toggle Blur •
    <kbd>L</kbd> Toggle Links
  </div>

  <div class="vignette"></div>

<script>
(() => {
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d', { alpha: true });
  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  // Resize canvas
  function resize(){
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // Utility
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const TAU = Math.PI * 2;

  // Mouse
  const mouse = { x: innerWidth/2, y: innerHeight/2, down:false };
  addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
  addEventListener('mousedown', () => mouse.down = true);
  addEventListener('mouseup',   () => mouse.down = false);

  // Config
  const CONFIG = {
    particleCount: Math.min(280, Math.floor(innerWidth * innerHeight / 9000)),
    baseSpeed: 0.35,
    linkDistance: 110,
    linkOpacity: 0.08,
    attractStrength: 0.08,
    repelStrength: 0.11,
    mouseRadius: 170,
    blur: true,
    drawLinks: true,
  };

  // Particles
  const particles = [];
  class Particle {
    constructor(i){
      this.i = i;
      this.reset(true);
    }
    reset(randomPos=false){
      this.x = randomPos ? rand(0, innerWidth) : clamp(this.x || innerWidth/2, 0, innerWidth);
      this.y = randomPos ? rand(0, innerHeight) : clamp(this.y || innerHeight/2, 0, innerHeight);
      const ang = rand(0, TAU);
      const spd = CONFIG.baseSpeed * rand(0.5, 1.6);
      this.vx = Math.cos(ang) * spd;
      this.vy = Math.sin(ang) * spd;
      this.size = rand(1.2, 2.6);
      this.hue = rand(170, 330);
      this.life = rand(6, 16);
      this.age = 0;
      this.tw = rand(.6, 1.6);
    }
    step(dt){
      // Soft noise via tiny per-particle orbit
      const t = (performance.now()/1000) * this.tw + this.i;
      this.vx += Math.cos(t*1.3) * 0.005;
      this.vy += Math.sin(t*1.7) * 0.005;

      // Mouse force
      const dx = mouse.x - this.x;
      const dy = mouse.y - this.y;
      const dist2 = dx*dx + dy*dy;
      const rad = CONFIG.mouseRadius;
      if (dist2 < rad*rad){
        const d = Math.sqrt(dist2) || 0.0001;
        const nx = dx / d, ny = dy / d;
        const strength = attract ? CONFIG.attractStrength : -CONFIG.repelStrength;
        const falloff = 1 - (d / rad);
        this.vx += nx * strength * falloff;
        this.vy += ny * strength * falloff;
      }

      // Drift
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // Soft wrap
      const m = 30;
      if (this.x < -m) this.x = innerWidth + m;
      if (this.x > innerWidth + m) this.x = -m;
      if (this.y < -m) this.y = innerHeight + m;
      if (this.y > innerHeight + m) this.y = -m;

      this.age += dt * 0.03;
      if (this.age > this.life) this.reset(true);
    }
    draw(){
      const alpha = 0.65;
      ctx.beginPath();
      ctx.fillStyle = `hsla(${this.hue}, 95%, 65%, ${alpha})`;
      ctx.arc(this.x, this.y, this.size, 0, TAU);
      ctx.shadowColor = `hsla(${this.hue}, 95%, 60%, .6)`;
      ctx.shadowBlur = CONFIG.blur ? 14 : 0;
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  // Init
  function init(){
    particles.length = 0;
    for (let i=0; i<CONFIG.particleCount; i++) {
      particles.push(new Particle(i));
    }
  }
  init();

  // Links buffer optimization
  function drawLinks(){
    if (!CONFIG.drawLinks) return;
    const maxDist2 = CONFIG.linkDistance * CONFIG.linkDistance;
    for (let i=0; i<particles.length; i++){
      const a = particles[i];
      for (let j=i+1; j<particles.length; j++){
        const b = particles[j];
        const dx = a.x - b.x, dy = a.y - b.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < maxDist2){
          const o = (1 - d2 / maxDist2) * CONFIG.linkOpacity;
          ctx.beginPath();
          ctx.strokeStyle = `rgba(180,220,255,${o})`;
          ctx.lineWidth = 1;
          ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }
  }

  // Time & loop
  let last = performance.now();
  let attract = true;

  // Orbs DOM refs
  const orbA = document.getElementById('orbA');
  const orbB = document.getElementById('orbB');
  const orbC = document.getElementById('orbC');
  const title = document.getElementById('title');

  function animate(now){
    const dt = Math.min(33, now - last) * 0.06; // normalize
    last = now;

    // Clear with faint trail for smoothness
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'lighter';

    // Steps
    for (let p of particles) p.step(dt);
    // Draw order
    for (let p of particles) p.draw();
    drawLinks();

    // Orb choreography (smooth, sin-driven)
    const t = now / 1000;
    const cx = innerWidth * 0.5;
    const cy = innerHeight * 0.5;
    const r1 = Math.min(innerWidth, innerHeight) * 0.35;
    const r2 = r1 * 0.9;
    const r3 = r1 * 0.8;

    positionOrb(orbA,
      cx + Math.cos(t*0.19) * r1,
      cy + Math.sin(t*0.22) * r1,
      1.05 + Math.sin(t*0.7)*0.03);

    positionOrb(orbB,
      cx + Math.cos(t*0.27 + 1.4) * r2,
      cy + Math.sin(t*0.24 + 0.6) * r2,
      1.08 + Math.cos(t*0.6)*0.05);

    positionOrb(orbC,
      cx + Math.cos(t*0.23 - 1.1) * r3,
      cy + Math.sin(t*0.31 - 0.8) * r3,
      0.98 + Math.sin(t*0.5)*0.06);

    // Subtle parallax for title
    const px = (mouse.x - cx) / innerWidth;
    const py = (mouse.y - cy) / innerHeight;
    title.style.transform = `translate3d(${px*12}px, ${py*10}px, 0)`;

    requestAnimationFrame(animate);
  }
  function positionOrb(el, x, y, s){
    el.style.left = x + 'px';
    el.style.top  = y + 'px';
    el.style.transform = `translate(-50%, -50%) scale(${s})`;
  }
  requestAnimationFrame(animate);

  // Keyboard controls
  addEventListener('keydown', (e)=>{
    if (e.code === 'Space'){
      attract = !attract;
      flash(`Mode: ${attract ? 'Attract' : 'Repel'}`);
      e.preventDefault();
    } else if (e.key.toLowerCase() === 'r'){
      init(); flash('Reset');
    } else if (e.key.toLowerCase() === 'b'){
      CONFIG.blur = !CONFIG.blur;
      flash(`Blur: ${CONFIG.blur ? 'On' : 'Off'}`);
    } else if (e.key.toLowerCase() === 'l'){
      CONFIG.drawLinks = !CONFIG.drawLinks;
      flash(`Links: ${CONFIG.drawLinks ? 'On' : 'Off'}`);
    }
  });

  // Tiny toast
  let toastEl;
  function flash(msg){
    if (!toastEl){
      toastEl = document.createElement('div');
      toastEl.style.position='fixed';
      toastEl.style.left='50%'; toastEl.style.top='8%';
      toastEl.style.transform='translate(-50%, -50%)';
      toastEl.style.padding='.55rem .8rem';
      toastEl.style.border='1px solid rgba(150,200,255,.35)';
      toastEl.style.background='rgba(10,18,34,.7)';
      toastEl.style.backdropFilter='blur(8px)';
      toastEl.style.color='#e8f2ff';
      toastEl.style.fontSize='.95rem';
      toastEl.style.borderRadius='12px';
      toastEl.style.boxShadow='0 0 30px rgba(120,180,255,.25)';
      toastEl.style.pointerEvents='none';
      document.body.appendChild(toastEl);
    }
    toastEl.textContent = msg;
    toastEl.style.opacity='1';
    toastEl.style.transition='none';
    requestAnimationFrame(()=>{
      toastEl.style.transition='opacity 1200ms ease';
      toastEl.style.opacity='0';
    });
  }

})();
</script>
</body>
</html>
