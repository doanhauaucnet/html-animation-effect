<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Nebula</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000005;
            cursor: none;
            font-family: 'Inter', sans-serif;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }

        .cursor-dot {
            width: 8px;
            height: 8px;
            background-color: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 10000;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 25px rgba(0, 255, 255, 0.5);
            transition: transform 0.1s ease-out, background-color 0.2s ease, box-shadow 0.2s ease;
        }
    </style>
</head>

<body>
    <canvas id="webgl-canvas"></canvas>
    <div class="cursor-dot"></div>

    <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer, particles;
        const PARTICLE_COUNT = 50000;
        let clickEffect = { position: new THREE.Vector2(), strength: 0, maxStrength: 1.2, decay: 0.96 };
        let burstEffect = { active: false, progress: 0, speed: 0.01 }; // slower speed
        const velocities = new Float32Array(PARTICLE_COUNT * 3);

        // --- Noise ---
        const F3 = 1.0 / 3.0, G3 = 1.0 / 6.0;
        const perm = new Uint8Array(512); for (let i = 0; i < 512; i++) perm[i] = Math.floor(Math.random() * 256);
        function grad3(i, x, y, z) { const h = i & 15; const u = h < 8 ? x : y; const v = h < 4 ? y : (h === 12 || h === 14 ? x : z); return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v); }
        function noise3D(x, y, z) {
            let n0, n1, n2, n3; const s = (x + y + z) * F3; const i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
            const t = (i + j + k) * G3; const X0 = i - t, Y0 = j - t, Z0 = k - t; const x0 = x - X0, y0 = y - Y0, z0 = z - Z0;
            let i1, j1, k1, i2, j2, k2;
            if (x0 >= y0) { if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } }
            else { if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } }
            const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
            const x2 = x0 - i2 + 2 * G3, y2 = y0 - j2 + 2 * G3, z2 = z0 - k2 + 2 * G3;
            const x3 = x0 - 1 + 3 * G3, y3 = y0 - 1 + 3 * G3, z3 = z0 - 1 + 3 * G3;
            const ii = i & 255, jj = j & 255, kk = k & 255;
            let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0; n0 = t0 < 0 ? 0 : (t0 *= t0, t0 * t0 * grad3(perm[ii + perm[jj + perm[kk]]], x0, y0, z0));
            let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1; n1 = t1 < 0 ? 0 : (t1 *= t1, t1 * t1 * grad3(perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]], x1, y1, z1));
            let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2; n2 = t2 < 0 ? 0 : (t2 *= t2, t2 * t2 * grad3(perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]], x2, y2, z2));
            let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3; n3 = t3 < 0 ? 0 : (t3 *= t3, t3 * t3 * grad3(perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]], x3, y3, z3));
            return 32 * (n0 + n1 + n2 + n3);
        }

        // --- Init ---
        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 3;
            scene = new THREE.Scene();

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const originalPositions = new Float32Array(PARTICLE_COUNT * 3);
            const color = new THREE.Color(); const radius = 2;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
                originalPositions[i * 3] = x; originalPositions[i * 3 + 1] = y; originalPositions[i * 3 + 2] = z;
                color.setHSL(0.5 + 0.2 * (i / PARTICLE_COUNT), 0.7, 0.5);
                colors[i * 3] = color.r; colors[i * 3 + 1] = color.g; colors[i * 3 + 2] = color.b;
                velocities[i * 3] = velocities[i * 3 + 1] = velocities[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('originalPosition', new THREE.BufferAttribute(originalPositions, 3));

            const material = new THREE.PointsMaterial({ size: 0.005, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8, depthWrite: false });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas'), antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('contextmenu', onRightClick);
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        function onMouseDown(event) { clickEffect.position.x = (event.clientX / window.innerWidth) * 2 - 1; clickEffect.position.y = -(event.clientY / window.innerHeight) * 2 + 1; clickEffect.strength = clickEffect.maxStrength; }
        function onRightClick(event) {
            event.preventDefault();
            burstEffect.active = true;
            burstEffect.progress = 0;

            // Record current positions as start of burst
            const positions = particles.geometry.attributes.position.array;
            burstEffect.startPositions = new Float32Array(positions);
        }

        // Easing function for smooth burst
        function smoothStep(t) { return t * t * (3 - 2 * t); }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.0002;
            const positions = particles.geometry.attributes.position.array;
            const originalPositions = particles.geometry.attributes.originalPosition.array;

            if (clickEffect.strength > 0) { clickEffect.strength *= clickEffect.decay; if (clickEffect.strength < 0.01) clickEffect.strength = 0; }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                const ox = originalPositions[ix], oy = originalPositions[iy], oz = originalPositions[iz];

                if (!burstEffect.active) {
                    let finalX = ox + noise3D(ox * 0.5 + time, oy * 0.5, oz * 0.5) * 0.1;
                    let finalY = oy + noise3D(ox * 0.5, oy * 0.5 + time, oz * 0.5) * 0.1;
                    let finalZ = oz + noise3D(ox * 0.5, oy * 0.5, oz * 0.5 + time) * 0.1;

                    if (clickEffect.strength > 0) {
                        const clickWorldX = clickEffect.position.x * (window.innerWidth / window.innerHeight) * 1.5;
                        const clickWorldY = clickEffect.position.y * 1.5;
                        const dx = finalX - clickWorldX, dy = finalY - clickWorldY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const wave = Math.sin(distance * 10 - Date.now() * 0.005) * Math.exp(-distance * 2);
                        const force = wave * clickEffect.strength * 0.2;
                        const angle = Math.atan2(dy, dx);
                        velocities[ix] += Math.cos(angle) * force;
                        velocities[iy] += Math.sin(angle) * force;
                    }

                    finalX += velocities[ix]; finalY += velocities[iy]; finalZ += velocities[iz];
                    velocities[ix] *= 0.92; velocities[iy] *= 0.92; velocities[iz] *= 0.92;

                    positions[ix] = finalX; positions[iy] = finalY; positions[iz] = finalZ;
                }
            }

            if (burstEffect.active) {
                burstEffect.progress += burstEffect.speed;
                if (burstEffect.progress >= 2) {
                    burstEffect.progress = 0;
                    burstEffect.active = false;
                }

                let t = burstEffect.progress <= 1 ? burstEffect.progress : 2 - burstEffect.progress;
                t = smoothStep(t);

                const startPositions = burstEffect.startPositions;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

                    const sx = startPositions[ix], sy = startPositions[iy], sz = startPositions[iz];
                    const cx = 0, cy = 0, cz = 0;

                    // Compute current noisy target
                    const ox = particles.geometry.attributes.originalPosition.array[ix];
                    const oy = particles.geometry.attributes.originalPosition.array[iy];
                    const oz = particles.geometry.attributes.originalPosition.array[iz];
                    const time = Date.now() * 0.0002;
                    const noiseX = ox + noise3D(ox * 0.5 + time, oy * 0.5, oz * 0.5) * 0.1;
                    const noiseY = oy + noise3D(ox * 0.5, oy * 0.5 + time, oz * 0.5) * 0.1;
                    const noiseZ = oz + noise3D(ox * 0.5, oy * 0.5, oz * 0.5 + time) * 0.1;

                    // Interpolate: start -> center -> current noisy position
                    positions[ix] = sx * (1 - t) + cx * t + (noiseX - sx) * (burstEffect.progress > 1 ? t - 1 : 0);
                    positions[iy] = sy * (1 - t) + cy * t + (noiseY - sy) * (burstEffect.progress > 1 ? t - 1 : 0);
                    positions[iz] = sz * (1 - t) + cz * t + (noiseZ - sz) * (burstEffect.progress > 1 ? t - 1 : 0);
                }
            }


            particles.geometry.attributes.position.needsUpdate = true;
            camera.position.z = 3; camera.lookAt(scene.position);
            composer.render();
        }

        // Cursor
        const cursorDot = document.querySelector('.cursor-dot');
        document.addEventListener('mousemove', e => { cursorDot.style.left = `${e.clientX}px`; cursorDot.style.top = `${e.clientY}px`; });

        init(); animate();
    </script>
</body>

</html>