<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Nebula</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000005;
            font-family: 'Inter', sans-serif;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }

    </style>
</head>

<body>
    <canvas id="webgl-canvas"></canvas>

    <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer, particles;
        const PARTICLE_COUNT = 50000;
        const velocities = new Float32Array(PARTICLE_COUNT * 3);

        let clickEffect = { position: new THREE.Vector2(), strength: 0, maxStrength: 0.5, decay: 0.96 };

        // --- Blue/White Moody Nebula Palette ---
        const themes = [
            [0.55, 0.60, 0.65], // deep blue
            [0.58, 0.70, 0.75], // lighter blue
            [0.6, 0.65, 0.7],   // cyan-blue
            [0.62, 0.72, 0.82], // bluish-white
            [0.0, 0.0, 0.0]     // pure white
        ];

        let currentThemeIndex = -1;
        const targetHues = new Float32Array(PARTICLE_COUNT);

        // --- Noise ---
        const F3 = 1.0 / 3.0, G3 = 1.0 / 6.0;
        const perm = new Uint8Array(512); for (let i = 0; i < 512; i++) perm[i] = Math.floor(Math.random() * 256);
        function grad3(i, x, y, z) { const h = i & 15; const u = h < 8 ? x : y; const v = h < 4 ? y : (h === 12 || h === 14 ? x : z); return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v); }
        function noise3D(x, y, z) {
            let n0, n1, n2, n3; const s = (x + y + z) * F3; const i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
            const t = (i + j + k) * G3; const X0 = i - t, Y0 = j - t, Z0 = k - t; const x0 = x - X0, y0 = y - Y0, z0 = z - Z0;
            let i1, j1, k1, i2, j2, k2;
            if (x0 >= y0) { if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } }
            else { if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } }
            const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
            const x2 = x0 - i2 + 2 * G3, y2 = y0 - j2 + 2 * G3, z2 = z0 - k2 + 2 * G3;
            const x3 = x0 - 1 + 3 * G3, y3 = y0 - 1 + 3 * G3, z3 = z0 - 1 + 3 * G3;
            const ii = i & 255, jj = j & 255, kk = k & 255;
            let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0; n0 = t0 < 0 ? 0 : (t0 *= t0, t0 * t0 * grad3(perm[ii + perm[jj + perm[kk]]], x0, y0, z0));
            let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1; n1 = t1 < 0 ? 0 : (t1 *= t1, t1 * t1 * grad3(perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]], x1, y1, z1));
            let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2; n2 = t2 < 0 ? 0 : (t2 *= t2, t2 * t2 * grad3(perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]], x2, y2, z2));
            let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3; n3 = t3 < 0 ? 0 : (t3 *= t3, t3 * t3 * grad3(perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]], x3, y3, z3));
            return 32 * (n0 + n1 + n2 + n3);
        }

        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3;
            scene = new THREE.Scene();

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const originalPositions = new Float32Array(PARTICLE_COUNT * 3);
            const color = new THREE.Color();
            const radius = 2;

            const initialTheme = themes[Math.floor(Math.random() * themes.length)];
            currentThemeIndex = themes.indexOf(initialTheme);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
                originalPositions[i * 3] = x; originalPositions[i * 3 + 1] = y; originalPositions[i * 3 + 2] = z;

                const hue = initialTheme[i % initialTheme.length];
                color.setHSL(hue, 0.6, 0.55);
                colors[i * 3] = color.r; colors[i * 3 + 1] = color.g; colors[i * 3 + 2] = color.b;
                targetHues[i] = hue;
                velocities[i * 3] = velocities[i * 3 + 1] = velocities[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('originalPosition', new THREE.BufferAttribute(originalPositions, 3));

            const material = new THREE.PointsMaterial({ size: 0.005, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.85, depthWrite: false });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas'), antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('contextmenu', onRightClick);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(event) {
            // Left click = ripple
            if (event.button === 0) {
                clickEffect.position.x = (event.clientX / window.innerWidth) * 2 - 1;
                clickEffect.position.y = -(event.clientY / window.innerHeight) * 2 + 1;
                clickEffect.strength = clickEffect.maxStrength;
            }
        }

        function onRightClick(event) {
            event.preventDefault();
            // Right click = change nebula color
            let nextThemeIndex;
            do { nextThemeIndex = Math.floor(Math.random() * themes.length); } 
            while (nextThemeIndex === currentThemeIndex);
            currentThemeIndex = nextThemeIndex;
            const newTheme = themes[nextThemeIndex];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                targetHues[i] = newTheme[i % newTheme.length];
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.0002;
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            const originalPositions = particles.geometry.attributes.originalPosition.array;

            if (clickEffect.strength > 0) clickEffect.strength *= clickEffect.decay;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                const ox = originalPositions[ix], oy = originalPositions[iy], oz = originalPositions[iz];

                positions[ix] = ox + noise3D(ox * 0.5 + time, oy * 0.5, oz * 0.5) * 0.1;
                positions[iy] = oy + noise3D(ox * 0.5, oy * 0.5 + time, oz * 0.5) * 0.1;
                positions[iz] = oz + noise3D(ox * 0.5, oy * 0.5, oz * 0.5 + time) * 0.1;

                if (clickEffect.strength > 0) {
                    const clickWorldX = clickEffect.position.x * (window.innerWidth / window.innerHeight) * 1.5;
                    const clickWorldY = clickEffect.position.y * 1.5;
                    const dx = positions[ix] - clickWorldX, dy = positions[iy] - clickWorldY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const wave = Math.sin(distance * 10 - Date.now() * 0.005) * Math.exp(-distance * 2);
                    const force = wave * clickEffect.strength * 0.2;
                    const angle = Math.atan2(dy, dx);
                    velocities[ix] += Math.cos(angle) * force;
                    velocities[iy] += Math.sin(angle) * force;
                }

                positions[ix] += velocities[ix];
                positions[iy] += velocities[iy];
                positions[iz] += velocities[iz];

                velocities[ix] *= 0.92; velocities[iy] *= 0.92; velocities[iz] *= 0.92;

                // Smooth color transition
                const color = new THREE.Color();
                const currentColor = new THREE.Color(colors[ix], colors[iy], colors[iz]);
                color.setHSL(targetHues[i], 0.6, 0.55);
                currentColor.lerp(color, 0.02);
                colors[ix] = currentColor.r;
                colors[iy] = currentColor.g;
                colors[iz] = currentColor.b;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            camera.position.z = 3;
            camera.lookAt(scene.position);
            composer.render();
        }

        init();
        animate();
    </script>
</body>

</html>
