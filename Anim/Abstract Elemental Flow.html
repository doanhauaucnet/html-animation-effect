<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Particle Simulation</title>
    <style>
        /* Basic CSS reset to ensure the canvas fills the entire screen */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            display: block;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <canvas id="elemental-canvas"></canvas>

    <script>
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 300; // Move camera back to see the particles

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('elemental-canvas'),
            antialias: true, // Smoother edges
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens

        // --- BLACK HOLE CORE ---
        // The central black sphere of the black hole
        const coreGeometry = new THREE.SphereGeometry(20, 32, 32);
        const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.95 });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);

        // --- PARTICLE SYSTEM (main cloud) ---
        const particleCount = 75000; // Increased particle count for a denser effect
        const positions = new Float32Array(particleCount * 3); // (x, y, z) for each particle
        const colors = new Float32Array(particleCount * 3); // (r, g, b) for each particle
        const originalPositions = new Float32Array(particleCount * 3); // Store initial positions

        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({
            size: 1.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending, // Creates a glowing effect
            transparent: true,
            opacity: 0.8,
            depthWrite: false, // Important for blending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Starfield background
        const starCount = 1000;
        const starPositions = new Float32Array(starCount * 3);
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
            size: 1,
            color: 0xffffff,
            blending: THREE.AdditiveBlending
        });

        for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            const r = 800 + Math.random() * 200;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos((Math.random() * 2) - 1);
            starPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
            starPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            starPositions[i3 + 2] = r * Math.cos(phi);
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // --- PARTICLE INITIALIZATION (main cloud) ---
        const particleData = [];
        const colorPalette = [
            new THREE.Color(0xff4500), // Fiery Orange
            new THREE.Color(0x1e90ff), // Watery Blue
            new THREE.Color(0xffd700), // Golden Light
            new THREE.Color(0xda70d6), // Ethereal Orchid
        ];

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            // Position particles in a large sphere for a 3D feel
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = Math.random() * 400 + 50;

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            positions[i3] = x;
            positions[i3 + 1] = y;
            positions[i3 + 2] = z;

            originalPositions[i3] = x;
            originalPositions[i3 + 1] = y;
            originalPositions[i3 + 2] = z;

            // Assign a random color from the palette
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;

            // Store original position and velocity for animation
            particleData.push({
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ),
                originalPos: new THREE.Vector3(x, y, z), // Store original position for reset
            });
        }

        // Set the attributes on the geometry
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // --- MOUSE INTERACTION FOR PARTICLE REPEL ---
        const mouse = new THREE.Vector2(0, 0);
        const targetMouse = new THREE.Vector2(0, 0);
        const mouseRepelStrength = 150; // How strongly particles are pushed by the mouse
        
        window.addEventListener('mousemove', (event) => {
            // Normalize mouse coordinates (-1 to +1)
            targetMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            targetMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        
        // Add touch support for mobile devices
        window.addEventListener('touchmove', (event) => {
            if (event.touches.length > 0) {
                targetMouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                targetMouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }, { passive: false });

        // --- CUSTOM LOGIC FOR STATE CHANGE ON CLICK ---
        let isPulling = true; // State flag: true = pulling, false = pushing
        let targetPhase = 0; // 0 for pulling, 1 for pushing
        let currentPhase = 0;

        window.addEventListener('click', () => {
            isPulling = !isPulling; // Toggle the state on each click
            targetPhase = isPulling ? 0 : 1;
        });

        // --- ANIMATION LOOP & BLACK HOLE LOGIC ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const positions = particles.geometry.attributes.position.array;
            
            // Smoothly interpolate mouse position for a softer follow effect
            mouse.x += (targetMouse.x - mouse.x) * 0.05;
            mouse.y += (targetMouse.y - mouse.y) * 0.05;
            
            // Convert normalized mouse coords to world coords
            const mouseWorld = new THREE.Vector3(mouse.x * (window.innerWidth/4), mouse.y * (window.innerHeight/4), 0);

            // Smoothly transition between phases
            currentPhase += (targetPhase - currentPhase) * 0.05;

            // Update core color and scale based on phase
            const coreColor = new THREE.Color().lerpColors(new THREE.Color(0x000000), new THREE.Color(0xffffff), currentPhase);
            core.material.color.copy(coreColor);
            core.scale.lerp(new THREE.Vector3(1 + currentPhase * 0.2, 1 + currentPhase * 0.2, 1 + currentPhase * 0.2), 0.05);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const pData = particleData[i];
                const pos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                const originalPos = pData.originalPos;

                // --- Black Hole Interaction ---
                const dirToCore = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), pos).normalize();
                const distanceToCore = pos.length() + 0.1;
                let coreForce;

                // Use the `isPulling` flag to determine the force direction
                if (isPulling) {
                    // Pulling phase
                    coreForce = -10 / (distanceToCore * 0.01 + 1);
                } else {
                    // Pushing phase
                    coreForce = 10 / (distanceToCore * 0.01 + 1);
                }

                pData.velocity.add(dirToCore.multiplyScalar(coreForce * 0.02)); // Reduced multiplier
                
                // --- Mouse Repel Interaction ---
                const distanceToMouse = pos.distanceTo(mouseWorld);
                if (distanceToMouse < mouseRepelStrength) {
                    const repelForce = (mouseRepelStrength - distanceToMouse) / mouseRepelStrength;
                    const repelVector = new THREE.Vector3().subVectors(pos, mouseWorld).normalize();
                    pData.velocity.add(repelVector.multiplyScalar(repelForce * 0.5));
                }

                // Add a gentle return force to the original position
                const returnForce = new THREE.Vector3().subVectors(originalPos, pos).multiplyScalar(0.0001);
                pData.velocity.add(returnForce);
                
                // Damping to slow down particles
                pData.velocity.multiplyScalar(0.97);

                // Update particle positions
                positions[i3] += pData.velocity.x;
                positions[i3 + 1] += pData.velocity.y;
                positions[i3 + 2] += pData.velocity.z;
            }

            // Mark the position attribute as needing an update
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Rotate the particle systems
            particles.rotation.y = elapsedTime * 0.05;
            particles.rotation.x = elapsedTime * 0.02;
            stars.rotation.y = elapsedTime * 0.01;
            stars.rotation.x = elapsedTime * 0.005;

            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        // Start the animation
        animate();
    </script>
</body>
</html>