<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Atom Visualization</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #00000a;
        font-family: "Inter", sans-serif;
        color: white;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="atom-canvas"></canvas>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      let scene, camera, renderer, composer;
      const electrons = [];
      let trailSystem;

      const ELECTRON_SPEED_BASE = 0.02;
      const ORBITAL_RADIUS = 5;

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 12;

        const canvas = document.getElementById("atom-canvas");
        renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: true,
          alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xff6666, 1, 100);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        const nucleusGeometry = new THREE.IcosahedronGeometry(1.5, 5);
        const nucleusMaterial = new THREE.MeshStandardMaterial({
          color: 0xff4444,
          emissive: 0xff2222,
          emissiveIntensity: 0.5,
          metalness: 0.5,
          roughness: 0.4,
          flatShading: true,
        });
        const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
        scene.add(nucleus);

        const electronCount = 8;
        const electronMaterial = new THREE.MeshBasicMaterial({
          color: 0x55bbff,
        });
        const trailTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png');

        const trailMaterial = new THREE.PointsMaterial({
        color: 0x55bbff,
        size: 0.1,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        opacity: 0.7,
        map: trailTexture,
        alphaTest: 0.01,
        });
        const trailGeometry = new THREE.BufferGeometry();
        const trailPositions = new Float32Array(electronCount * 100 * 3);
        trailGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(trailPositions, 3)
        );
        trailSystem = new THREE.Points(trailGeometry, trailMaterial);
        scene.add(trailSystem);

        for (let i = 0; i < electronCount; i++) {
          const electronGroup = new THREE.Group();
          scene.add(electronGroup);

          const electronGeometry = new THREE.SphereGeometry(0.2, 16, 16);
          const electron = new THREE.Mesh(electronGeometry, electronMaterial);
          electronGroup.add(electron);

          const radiusX = ORBITAL_RADIUS;
          const radiusZ = ORBITAL_RADIUS;

          const trail = [];
          for (let j = 0; j < 100; j++) trail.push(new THREE.Vector3());

          const angleStep = (Math.PI * 2) / electronCount;

          electrons.push({
            mesh: electron,
            group: electronGroup,
            radiusX,
            radiusZ,
            speed: ELECTRON_SPEED_BASE,
            angle: i * angleStep,
            trail,
            trailIndex: 0,
          });

          electronGroup.rotation.x = Math.random() * Math.PI;
          electronGroup.rotation.y = Math.random() * Math.PI;
          electronGroup.rotation.z = Math.random() * Math.PI;
        }

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.5;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.0005;
        const positions = trailSystem.geometry.attributes.position;

        electrons.forEach((e, i) => {
          e.angle += e.speed;
          const x = Math.cos(e.angle) * e.radiusX;
          const z = Math.sin(e.angle) * e.radiusZ;
          e.mesh.position.set(x, 0, z);

          const currentPos = new THREE.Vector3();
          e.mesh.getWorldPosition(currentPos);
          e.trail[e.trailIndex].copy(currentPos);
          e.trailIndex = (e.trailIndex + 1) % e.trail.length;

          for (let j = 0; j < e.trail.length; j++) {
            const index = (i * e.trail.length + j) * 3;
            positions.array[index] = e.trail[j].x;
            positions.array[index + 1] = e.trail[j].y;
            positions.array[index + 2] = e.trail[j].z;
          }
        });
        positions.needsUpdate = true;

        const nucleus = scene.children.find(
          (c) => c.geometry instanceof THREE.IcosahedronGeometry
        );
        if (nucleus) {
          nucleus.material.emissiveIntensity = Math.sin(time * 2) * 0.25 + 0.75;
          nucleus.rotation.y += 0.001;
          nucleus.rotation.x += 0.0005;
        }

        camera.position.x = Math.sin(time * 0.2) * 2;
        camera.position.y = Math.sin(time * 0.1) * 1;
        camera.lookAt(0, 0, 0);

        composer.render();
      }

      init();
      animate();
    </script>
  </body>
</html>
