<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flocking Boids</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #0c0a18; /* Deep indigo background */
        font-family: "Inter", sans-serif;
        color: white;
      }

      canvas {
        display: block;
      }

      h1 {
        font-size: 1.5rem;
        margin: 0;
        font-weight: 400;
      }

      p {
        font-size: 0.9rem;
        margin: 5px 0 0;
        font-weight: 300;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <canvas id="boids-canvas"></canvas>

    <script>
      const canvas = document.getElementById("boids-canvas");
      const ctx = canvas.getContext("2d");

      let width, height;
      const flock = [];
      const groups = [];
      const predators = [];
      const particleEffects = [];
      const mouse = { x: null, y: null, radius: 100 }; // Mouse repels boids
      let initialBoidCount = 0;

      class ParticleEffect {
        constructor(x, y, type) {
          this.position = { x, y };
          this.type = type;
          this.particles = [];

          if (this.type === "spawn") {
            this.lifespan = 40;
            this.radius = 1;
            this.maxRadius = 70;
          } else if (this.type === "despawn") {
            this.lifespan = 40;
            this.radius = 70;
            this.minRadius = 1;
          } else if (this.type === "eaten") {
            for (let i = 0; i < 10; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = 1 + Math.random() * 2;
              this.particles.push({
                x: this.position.x,
                y: this.position.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                lifespan: 20 + Math.random() * 10,
                hue: 170 + Math.random() * 80,
              });
            }
          }
        }

        update() {
          if (this.type === "eaten") {
            for (let i = this.particles.length - 1; i >= 0; i--) {
              const p = this.particles[i];
              p.x += p.vx;
              p.y += p.vy;
              p.lifespan--;
              if (p.lifespan <= 0) {
                this.particles.splice(i, 1);
              }
            }
          } else {
            this.lifespan--;
          }
        }

        isFinished() {
          return (
            (this.type === "eaten" && this.particles.length === 0) ||
            this.lifespan <= 0
          );
        }

        draw() {
          const progress = this.lifespan / 40;
          if (this.type === "spawn") {
            const currentRadius = this.maxRadius * (1 - progress);
            ctx.strokeStyle = `rgba(255, 80, 80, ${progress})`;
            ctx.lineWidth = 3 * progress;
            ctx.beginPath();
            ctx.arc(
              this.position.x,
              this.position.y,
              currentRadius,
              0,
              Math.PI * 2
            );
            ctx.stroke();
          } else if (this.type === "despawn") {
            const currentRadius =
              this.minRadius + (this.radius - this.minRadius) * progress;
            ctx.strokeStyle = `rgba(255, 80, 80, ${progress})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(
              this.position.x,
              this.position.y,
              currentRadius,
              0,
              Math.PI * 2
            );
            ctx.stroke();
          } else if (this.type === "eaten") {
            for (const p of this.particles) {
              const opacity = p.lifespan / 30;
              ctx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${opacity})`;
              ctx.beginPath();
              ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      }

      class Boid {
        constructor(x, y, groupId, groupHue) {
          this.position = {
            x: x || Math.random() * width,
            y: y || Math.random() * height,
          };
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 2;
          this.velocity = {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed,
          };
          this.acceleration = { x: 0, y: 0 };
          this.maxForce = 0.05;
          this.maxSpeed = 4;
          this.perceptionRadius = 50;
          this.groupId = groupId;
          this.hue = groupHue + (Math.random() - 0.5) * 20; // Slight variation from group color
        }

        _calculateSteeringForce(desired) {
          let steering = {
            x: desired.x - this.velocity.x,
            y: desired.y - this.velocity.y,
          };
          const forceMag = Math.sqrt(
            steering.x * steering.x + steering.y * steering.y
          );
          if (forceMag > this.maxForce) {
            steering.x = (steering.x / forceMag) * this.maxForce;
            steering.y = (steering.y / forceMag) * this.maxForce;
          }
          return steering;
        }

        seek(target) {
          let desired = {
            x: target.x - this.position.x,
            y: target.y - this.position.y,
          };
          const mag = Math.sqrt(desired.x * desired.x + desired.y * desired.y);
          desired.x = (desired.x / mag) * this.maxSpeed;
          desired.y = (desired.y / mag) * this.maxSpeed;
          return this._calculateSteeringForce(desired);
        }

        flee(target) {
          const fleeRadius =
            target instanceof Predator
              ? this.perceptionRadius * 2.5
              : mouse.radius;
          const d = Math.sqrt(
            Math.pow(this.position.x - target.x, 2) +
              Math.pow(this.position.y - target.y, 2)
          );

          if (d < fleeRadius) {
            let desired = {
              x: this.position.x - target.x,
              y: this.position.y - target.y,
            };
            const mag = Math.sqrt(
              desired.x * desired.x + desired.y * desired.y
            );
            desired.x = (desired.x / mag) * this.maxSpeed;
            desired.y = (desired.y / mag) * this.maxSpeed;
            return this._calculateSteeringForce(desired);
          }
          return { x: 0, y: 0 };
        }

        align(groupMates) {
          let steering = { x: 0, y: 0 };
          let total = 0;
          for (let other of groupMates) {
            const d = Math.sqrt(
              Math.pow(this.position.x - other.position.x, 2) +
                Math.pow(this.position.y - other.position.y, 2)
            );
            if (other !== this && d < this.perceptionRadius) {
              steering.x += other.velocity.x;
              steering.y += other.velocity.y;
              total++;
            }
          }
          if (total > 0) {
            steering.x /= total;
            steering.y /= total;
            const mag = Math.sqrt(
              steering.x * steering.x + steering.y * steering.y
            );
            steering.x = (steering.x / mag) * this.maxSpeed;
            steering.y = (steering.y / mag) * this.maxSpeed;
            return this._calculateSteeringForce(steering);
          }
          return steering;
        }

        cohesion(groupMates) {
          let steering = { x: 0, y: 0 };
          let total = 0;
          for (let other of groupMates) {
            const d = Math.sqrt(
              Math.pow(this.position.x - other.position.x, 2) +
                Math.pow(this.position.y - other.position.y, 2)
            );
            if (other !== this && d < this.perceptionRadius) {
              steering.x += other.position.x;
              steering.y += other.position.y;
              total++;
            }
          }
          if (total > 0) {
            steering.x /= total;
            steering.y /= total;
            let desired = {
              x: steering.x - this.position.x,
              y: steering.y - this.position.y,
            };
            const mag = Math.sqrt(
              desired.x * desired.x + desired.y * desired.y
            );
            desired.x = (desired.x / mag) * this.maxSpeed;
            desired.y = (desired.y / mag) * this.maxSpeed;
            return this._calculateSteeringForce(desired);
          }
          return { x: 0, y: 0 };
        }

        separation(groupMates) {
          let steering = { x: 0, y: 0 };
          let total = 0;
          for (let other of groupMates) {
            const d = Math.sqrt(
              Math.pow(this.position.x - other.position.x, 2) +
                Math.pow(this.position.y - other.position.y, 2)
            );
            if (other !== this && d < this.perceptionRadius / 1.5) {
              let diffX = this.position.x - other.position.x;
              let diffY = this.position.y - other.position.y;
              diffX /= d * d;
              diffY /= d * d;
              steering.x += diffX;
              steering.y += diffY;
              total++;
            }
          }
          if (total > 0) {
            steering.x /= total;
            steering.y /= total;
            const mag = Math.sqrt(
              steering.x * steering.x + steering.y * steering.y
            );
            steering.x = (steering.x / mag) * this.maxSpeed;
            steering.y = (steering.y / mag) * this.maxSpeed;
            return this._calculateSteeringForce(steering);
          }
          return steering;
        }

        flock(groupMates, groupLeader, predators) {
          let alignment = this.align(groupMates);
          let cohesion = this.cohesion(groupMates);
          let separation = this.separation(groupMates);
          let leaderFollow = this.seek(groupLeader.position);

          // Classic flocking forces
          this.acceleration.x += separation.x * 1.5;
          this.acceleration.y += separation.y * 1.5;
          this.acceleration.x += alignment.x * 1.0;
          this.acceleration.y += alignment.y * 1.0;
          this.acceleration.x += cohesion.x * 1.0;
          this.acceleration.y += cohesion.y * 1.0;
          // Force to follow the group leader
          this.acceleration.x += leaderFollow.x * 0.5;
          this.acceleration.y += leaderFollow.y * 0.5;

          for (const predator of predators) {
            let flee = this.flee(predator.position);
            this.acceleration.x += flee.x * 3.0; // Fleeing is high priority
            this.acceleration.y += flee.y * 3.0;
          }

          if (mouse.x !== null) {
            let repel = this.flee(mouse);
            this.acceleration.x += repel.x * 2.0;
            this.acceleration.y += repel.y * 2.0;
          }
        }

        edges() {
          if (this.position.x > width + 10) this.position.x = -10;
          else if (this.position.x < -10) this.position.x = width + 10;
          if (this.position.y > height + 10) this.position.y = -10;
          else if (this.position.y < -10) this.position.y = height + 10;
        }

        update() {
          this.position.x += this.velocity.x;
          this.position.y += this.velocity.y;
          this.velocity.x += this.acceleration.x;
          this.velocity.y += this.acceleration.y;

          const mag = Math.sqrt(
            this.velocity.x * this.velocity.x +
              this.velocity.y * this.velocity.y
          );
          if (mag > this.maxSpeed) {
            this.velocity.x = (this.velocity.x / mag) * this.maxSpeed;
            this.velocity.y = (this.velocity.y / mag) * this.maxSpeed;
          }

          this.acceleration.x = 0;
          this.acceleration.y = 0;
        }

        draw() {
          const angle = Math.atan2(this.velocity.y, this.velocity.x);
          ctx.save();
          ctx.translate(this.position.x, this.position.y);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(10, 0); // tip
          ctx.quadraticCurveTo(0, -5, -5, 0);
          ctx.quadraticCurveTo(0, 5, 10, 0);
          ctx.closePath();
          const lightness =
            60 +
            (Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2) /
              this.maxSpeed) *
              20;
          ctx.fillStyle = `hsl(${this.hue}, 100%, ${lightness}%)`;
          ctx.shadowColor = `hsl(${this.hue}, 100%, 60%)`;
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.restore();
        }
      }

      class Predator extends Boid {
        constructor(x, y) {
          super(x, y);
          this.maxSpeed = 5; // Slightly faster
          this.maxForce = 0.1;
          this.hue = 0; // Red
          this.perceptionRadius = 200; // Can see farther
        }

        seek(boids) {
          let closest = null;
          let closestDist = Infinity;
          for (let boid of boids) {
            const d = Math.sqrt(
              Math.pow(this.position.x - boid.position.x, 2) +
                Math.pow(this.position.y - boid.position.y, 2)
            );
            if (d < closestDist && d < this.perceptionRadius) {
              closestDist = d;
              closest = boid;
            }
          }

          if (closest) {
            let desired = {
              x: closest.position.x - this.position.x,
              y: closest.position.y - this.position.y,
            };
            const mag = Math.sqrt(
              desired.x * desired.x + desired.y * desired.y
            );
            desired.x = (desired.x / mag) * this.maxSpeed;
            desired.y = (desired.y / mag) * this.maxSpeed;

            const steering = this._calculateSteeringForce(desired);
            this.acceleration.x += steering.x;
            this.acceleration.y += steering.y;
          }
        }

        draw() {
          const angle = Math.atan2(this.velocity.y, this.velocity.x);
          ctx.save();
          ctx.translate(this.position.x, this.position.y);
          ctx.rotate(angle);
          ctx.beginPath();
          // Larger, more aggressive triangle
          ctx.moveTo(15, 0);
          ctx.lineTo(-7, -7);
          ctx.lineTo(-7, 7);
          ctx.closePath();
          ctx.fillStyle = `hsl(${this.hue}, 100%, 65%)`;
          ctx.shadowColor = `hsl(${this.hue}, 100%, 65%)`;
          ctx.shadowBlur = 15;
          ctx.fill();
          ctx.restore();
        }
      }

      class GroupLeader {
        constructor() {
          this.position = {
            x: Math.random() * width,
            y: Math.random() * height,
          };
          const angle = Math.random() * Math.PI * 2;
          const speed = 1 + Math.random() * 1;
          this.velocity = {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed,
          };
        }
        update() {
          this.position.x += this.velocity.x;
          this.position.y += this.velocity.y;

          if (Math.random() < 0.05) {
            // Occasionally change direction
            const angle = Math.random() * Math.PI * 2;
            this.velocity.x = Math.cos(angle) * (1 + Math.random() * 1);
            this.velocity.y = Math.sin(angle) * (1 + Math.random() * 1);
          }

          if (this.position.x > width) this.position.x = 0;
          else if (this.position.x < 0) this.position.x = width;
          if (this.position.y > height) this.position.y = 0;
          else if (this.position.y < 0) this.position.y = height;
        }
      }

      function setup() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        flock.length = 0;
        predators.length = 0;
        particleEffects.length = 0;
        groups.length = 0;

        initialBoidCount = Math.floor((width * height) / 8000);
        const numGroups = Math.max(2, Math.floor(initialBoidCount / 40));
        const baseHues = [180, 240, 280, 200, 300]; // Cyan, Blue, Purple, Green-ish, Magenta-ish

        for (let i = 0; i < numGroups; i++) {
          groups.push({
            id: i,
            hue: baseHues[i % baseHues.length],
            leader: new GroupLeader(),
          });
        }

        for (let i = 0; i < initialBoidCount; i++) {
          const group = groups[i % numGroups];
          flock.push(new Boid(null, null, group.id, group.hue));
        }
      }

      function animate() {
        ctx.fillStyle = "rgba(12, 10, 24, 0.2)";
        ctx.fillRect(0, 0, width, height);

        for (let i = particleEffects.length - 1; i >= 0; i--) {
          const effect = particleEffects[i];
          effect.update();
          effect.draw();
          if (effect.isFinished()) {
            particleEffects.splice(i, 1);
          }
        }

        groups.forEach((g) => g.leader.update());

        for (let boid of flock) {
          const groupMates = flock.filter(
            (other) => other.groupId === boid.groupId
          );
          const groupLeader = groups[boid.groupId].leader;
          boid.edges();
          boid.flock(groupMates, groupLeader, predators);
          boid.update();
          boid.draw();
        }

        for (let i = predators.length - 1; i >= 0; i--) {
          const predator = predators[i];
          predator.edges();
          predator.seek(flock);
          predator.update();
          predator.draw();

          for (let j = flock.length - 1; j >= 0; j--) {
            const boid = flock[j];
            const d = Math.sqrt(
              Math.pow(predator.position.x - boid.position.x, 2) +
                Math.pow(predator.position.y - boid.position.y, 2)
            );
            if (d < 10) {
              // Eating distance
              particleEffects.push(
                new ParticleEffect(boid.position.x, boid.position.y, "eaten")
              );
              flock.splice(j, 1);
            }
          }
        }

        // Population control
        if (flock.length < initialBoidCount / 2 && Math.random() < 0.02) {
          const group = groups[Math.floor(Math.random() * groups.length)];
          flock.push(new Boid(null, null, group.id, group.hue));
        }

        requestAnimationFrame(animate);
      }

      window.addEventListener("resize", setup);
      canvas.addEventListener("click", (e) => {
        if (predators.length >= 3) {
          const oldestPredator = predators.shift(); // Remove the first (oldest) predator
          particleEffects.push(
            new ParticleEffect(
              oldestPredator.position.x,
              oldestPredator.position.y,
              "despawn"
            )
          );
        }
        predators.push(new Predator(e.clientX, e.clientY));
        particleEffects.push(new ParticleEffect(e.clientX, e.clientY, "spawn"));
      });
      window.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });
      window.addEventListener("mouseleave", () => {
        mouse.x = null;
        mouse.y = null;
      });

      setup();
      animate();
    </script>
  </body>
</html>
