<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Solar System Visualization</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="solarSystem"></canvas>
<script>
const canvas = document.getElementById('solarSystem');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
});
const centerX = width/2;
const centerY = height/2;
// Sun
const sun = { x: centerX, y: centerY, radius: 50, color: 'yellow', spinAngle: 0, spinSpeed: 0.001 };
// Planets data with moons and asteroid belts
const planets = [
    { name: 'Mercury', color: '#a9a9a9', radius: 5, distance: 70, speed: 0.04, angle: Math.random()*Math.PI*2, moons: [] },
    { name: 'Venus', color: '#eccc9a', radius: 8, distance: 100, speed: 0.015, angle: Math.random()*Math.PI*2, moons: [] },
    { name: 'Earth', color: '#3d85c6', radius: 9, distance: 140, speed: 0.01, angle: Math.random()*Math.PI*2,
      moons: [{ radius: 3, distance: 15, speed: 0.05, angle: Math.random()*Math.PI*2 }] },
    { name: 'Mars', color: '#b22222', radius: 7, distance: 180, speed: 0.008, angle: Math.random()*Math.PI*2,
      moons: [{ radius: 2, distance: 12, speed: 0.06, angle: Math.random()*Math.PI*2 }, { radius: 1.5, distance: 18, speed: 0.03, angle: Math.random()*Math.PI*2 }] },
    { name: 'Jupiter', color: '#d9a066', radius: 20, distance: 250, speed: 0.004, angle: Math.random()*Math.PI*2,
      moons: [{ radius: 4, distance: 28, speed: 0.02, angle: Math.random()*Math.PI*2 }, { radius: 3, distance: 35, speed: 0.015, angle: Math.random()*Math.PI*2 }],
      asteroids: Array.from({length:100},()=>({angle: Math.random()*Math.PI*2, distance: 60+Math.random()*40, speed: 0.005+Math.random()*0.002})) },
    { name: 'Saturn', color: '#f5deb3', radius: 18, distance: 320, speed: 0.003, angle: Math.random()*Math.PI*2,
      moons: [{ radius: 3, distance: 25, speed: 0.015, angle: Math.random()*Math.PI*2 }],
      asteroids: Array.from({length:150},()=>({angle: Math.random()*Math.PI*2, distance: 60+Math.random()*50, speed: 0.004+Math.random()*0.002})) },
    { name: 'Uranus', color: '#7fffd4', radius: 12, distance: 390, speed: 0.002, angle: Math.random()*Math.PI*2, moons: [] },
    { name: 'Neptune', color: '#4169e1', radius: 12, distance: 460, speed: 0.0015, angle: Math.random()*Math.PI*2, moons: [] }
];
// Solar prominence particles (the new arc-like particles)
const prominences = [];
let lastSpawnTime = 0;
const spawnInterval = 3000; // in milliseconds, 3 seconds
function drawSun() {
    ctx.save();
    ctx.translate(sun.x, sun.y);
    ctx.rotate(sun.spinAngle);
    const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, sun.radius);
    gradient.addColorStop(0, '#fffacd');
    gradient.addColorStop(1, sun.color);
    ctx.beginPath();
    ctx.fillStyle = gradient;
    ctx.arc(0, 0, sun.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    sun.spinAngle += sun.spinSpeed;
}
function drawPlanets() {
    planets.forEach(p => {
        // Planet position
        const x = centerX + Math.cos(p.angle) * p.distance;
        const y = centerY + Math.sin(p.angle) * p.distance * 0.6; // ellipse for 3D perspective
        // Orbit path
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.ellipse(centerX, centerY, p.distance, p.distance*0.6, 0, 0, Math.PI*2);
        ctx.stroke();
        // Planet
        ctx.beginPath();
        ctx.fillStyle = p.color;
        ctx.arc(x, y, p.radius, 0, Math.PI*2);
        ctx.fill();
        // Moons
        if(p.moons){
            p.moons.forEach(m => {
                const mx = x + Math.cos(m.angle) * m.distance;
                const my = y + Math.sin(m.angle) * m.distance * 0.6;
                ctx.beginPath();
                ctx.fillStyle = 'gray';
                ctx.arc(mx, my, m.radius, 0, Math.PI*2);
                ctx.fill();
                m.angle += m.speed;
            });
        }
        // Asteroids
        if(p.asteroids){
            p.asteroids.forEach(a => {
                const ax = x + Math.cos(a.angle) * a.distance;
                const ay = y + Math.sin(a.angle) * a.distance * 0.5;
                ctx.beginPath();
                ctx.fillStyle = 'white';
                ctx.arc(ax, ay, 1, 0, Math.PI*2);
                ctx.fill();
                a.angle += a.speed;
            });
        }
        p.angle += p.speed;
    });
}
// New function to handle solar prominence
function drawProminence() {
    // Check if it's time to spawn a new arc
    if (Date.now() - lastSpawnTime > spawnInterval) {
        lastSpawnTime = Date.now();
        const arcCount = Math.floor(Math.random() * 3) + 1; // 1 to 3 arcs at a time
        for (let i = 0; i < arcCount; i++) {
            spawnProminence();
        }
    }
    // Update and draw each particle in the prominences array
    for (let i = prominences.length - 1; i >= 0; i--) {
        const p = prominences[i];
        p.progress += p.speed;
        if (p.progress >= 1) {
            prominences.splice(i, 1); // Remove completed particle
            continue;
        }
        // Calculate position on a quadratic bezier curve
        const t = p.progress;
        const x = (1 - t) * (1 - t) * p.startX + 2 * (1 - t) * t * p.controlX + t * t * p.endX;
        const y = (1 - t) * (1 - t) * p.startY + 2 * (1 - t) * t * p.controlY + t * t * p.endY;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 165, 0, ${1 - t})`; // Use the color of the flares and fade out
        ctx.arc(x, y, p.size, 0, Math.PI*2);
        ctx.fill();
    }
}
function spawnProminence() {
    const spawnDelay = 15; // Delay in milliseconds between spawning particles
    const arcHeight = Math.random() * 200 + 100; // Make arc taller
    const startAngle = Math.random() * Math.PI * 2;
    const arcLength = Math.random() * (Math.PI / 2) + (Math.PI / 2); // Make the arc longer
    const endAngle = startAngle + arcLength * (Math.random() > 0.5 ? 1 : -1);
    const particleCount = 50; // More particles for smoother effect
    const startX = sun.x + Math.cos(startAngle) * sun.radius;
    const startY = sun.y + Math.sin(startAngle) * sun.radius;
    const endX = sun.x + Math.cos(endAngle) * sun.radius;
    const endY = sun.y + Math.sin(endAngle) * sun.radius;
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const dx = endX - startX;
    const dy = endY - startY;
    const controlPointX = midX + -dy * (arcHeight / Math.sqrt(dx * dx + dy * dy));
    const controlPointY = midY + dx * (arcHeight / Math.sqrt(dx * dx + dy * dy));
    for (let i = 0; i < particleCount; i++) {
        setTimeout(() => {
            const offset = (Math.random() - 0.5) * 20; // Random spread offset
            prominences.push({
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY,
                controlX: controlPointX + (offset * -dy / Math.sqrt(dx * dx + dy * dy)),
                controlY: controlPointY + (offset * dx / Math.sqrt(dx * dx + dy * dy)),
                progress: 0,
                speed: 0.002, // Much slower speed for a longer, smoother flow
                size: Math.random() * 2 + 1,
            });
        }, i * spawnDelay);
    }
}
function animate() {
    ctx.clearRect(0,0,width,height);
    drawSun();
    drawPlanets();
    drawProminence();
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>