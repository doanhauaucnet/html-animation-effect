<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Orb Simulation</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

const COLORS = {
  PURPLE: { main: '#ff00ff', glow: '#ff00ff' },
  BLUE: { main: '#00ffff', glow: '#00ffff' },
  WHITE: { main: '#ffffff', glow: '#ffffff' }
};
const ORB_COUNT_PER_COLOR = 10;
const MAX_SPEED = 1.5;

class Orb {
  constructor(x, y, radius, color) {
    this.x = x;
    this.y = y;
    this.radius = radius; // core radius
    this.outerRadius = radius * 1.2; // includes glow
    this.color = color;
    this.vx = (Math.random() - 0.5) * MAX_SPEED;
    this.vy = (Math.random() - 0.5) * MAX_SPEED;
  }

  draw() {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.translate(this.x, this.y);

    // Core
    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
    coreGrad.addColorStop(0, this.color.main + 'ff');
    coreGrad.addColorStop(0.3, this.color.main + 'cc');
    coreGrad.addColorStop(1, this.color.main + '00');
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
    ctx.fill();

    // Glow
    const glowGrad = ctx.createRadialGradient(0, 0, this.radius * 0.8, 0, 0, this.radius * 1.2);
    glowGrad.addColorStop(0, 'rgba(255,255,255,0)');
    glowGrad.addColorStop(0.8, this.color.glow + '33');
    glowGrad.addColorStop(1, this.color.glow + '88');
    ctx.strokeStyle = glowGrad;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, this.radius * 1.2, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;

    // Bounce off edges
    if (this.x - this.radius < 0 || this.x + this.radius > width) this.vx *= -1;
    if (this.y - this.radius < 0 || this.y + this.radius > height) this.vy *= -1;
  }
}

// Create orbs
let orbs = [];
for (const colorKey in COLORS) {
  for (let i = 0; i < ORB_COUNT_PER_COLOR; i++) {
    const r = Math.random() * 15 + 10;
    const x = Math.random() * (width - 2*r) + r;
    const y = Math.random() * (height - 2*r) + r;
    orbs.push(new Orb(x, y, r, COLORS[colorKey]));
  }
}

// Handle collisions between orbs
function handleCollisions() {
  for (let i = 0; i < orbs.length; i++) {
    for (let j = i + 1; j < orbs.length; j++) {
      const o1 = orbs[i];
      const o2 = orbs[j];
      const dx = o2.x - o1.x;
      const dy = o2.y - o1.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const minDist = o1.outerRadius + o2.outerRadius; // <-- use outerRadius
      if (dist < minDist) {
        const angle = Math.atan2(dy, dx);
        const overlap = minDist - dist;
        const moveX = Math.cos(angle) * overlap / 2;
        const moveY = Math.sin(angle) * overlap / 2;
        o1.x -= moveX; o1.y -= moveY;
        o2.x += moveX; o2.y += moveY;

        // Simple bounce
        const tempVx = o1.vx;
        const tempVy = o1.vy;
        o1.vx = o2.vx;
        o1.vy = o2.vy;
        o2.vx = tempVx;
        o2.vy = tempVy;
      }
    }
  }
}

// Animate
function animate() {
  ctx.clearRect(0, 0, width, height);
  orbs.forEach(o => { o.update(); o.draw(); });
  handleCollisions();
  requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
});

animate();
</script>
</body>
</html>
