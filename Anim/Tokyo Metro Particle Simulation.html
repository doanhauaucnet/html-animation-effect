<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tokyo Metro Particle Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a;
            color: #f0f0f0;
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Allow clicks to pass through to canvas if needed */
        }
        .ui-container > * {
            pointer-events: auto; /* Re-enable pointer events for UI elements */
        }
    </style>
</head>
<body class="w-screen h-screen">

    <canvas id="particleCanvas"></canvas>

    <div class="ui-container flex flex-col items-center justify-between p-4 md:p-8">
        <div class="text-center bg-black/30 backdrop-blur-sm p-4 rounded-lg">
            <h1 class="text-2xl md:text-4xl font-bold text-white tracking-wider">Tokyo Metro Data Stream</h1>
            <p class="text-gray-300 text-sm md:text-base mt-2">An artistic visualization of a dynamic particle network</p>
        </div>

        <div class="text-center bg-black/30 backdrop-blur-sm py-2 px-4 rounded-lg text-xs text-gray-400">
            Move your mouse to interact with the particle flow
        </div>
    </div>


    <script>
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        // --- Configuration ---
        const PARTICLE_COUNT = 150;
        const PARTICLE_SPEED = 0.8;
        const STATION_RADIUS = 5;
        const GLOW_RADIUS = 12;
        const MOUSE_INFLUENCE_RADIUS = 150;
        const MOUSE_REPEL_STRENGTH = 2;

        let mouse = { x: null, y: null };

        // --- Data for the Metro Map ---
        // Simplified and artistically arranged station coordinates and lines
        const stations = {
            'Shibuya': { x: width * 0.25, y: height * 0.8 },
            'Shinjuku': { x: width * 0.2, y: height * 0.5 },
            'Ikebukuro': { x: width * 0.35, y: height * 0.2 },
            'Ueno': { x: width * 0.75, y: height * 0.2 },
            'Tokyo': { x: width * 0.65, y: height * 0.6 },
            'Ginza': { x: width * 0.55, y: height * 0.7 },
            'Akasaka': { x: width * 0.4, y: height * 0.65 },
            'Otemachi': { x: width * 0.6, y: height * 0.5 },
            'Korakuen': { x: width * 0.5, y: height * 0.35 },
            'Roppongi': { x: width * 0.4, y: height * 0.8 },
            'Nakano': { x: width * 0.05, y: height * 0.45 },
            'Kitasenju': { x: width * 0.9, y: height * 0.1 },
        };

        const lines = [
            { color: '#ff9500', path: ['Shibuya', 'Akasaka', 'Ginza', 'Tokyo', 'Ueno'] }, // Ginza Line (Orange)
            { color: '#f62e36', path: ['Ikebukuro', 'Korakuen', 'Otemachi', 'Tokyo', 'Ginza', 'Akasaka', 'Shinjuku'] }, // Marunouchi Line (Red)
            { color: '#009b48', path: ['Shibuya', 'Akasaka', 'Otemachi', 'Kitasenju'] }, // Chiyoda Line (Green)
            { color: '#0078ba', path: ['Nakano', 'Shinjuku', 'Otemachi', 'Tokyo'] }, // Tozai Line (Blue)
            { color: '#a0a2a1', path: ['Roppongi', 'Shinjuku', 'Ueno', 'Kitasenju'] }, // Hibiya Line (Silver)
            { color: '#8e5e98', path: ['Shibuya', 'Otemachi', 'Kitasenju'] }, // Hanzomon Line (Purple)
        ];

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                const line = lines[Math.floor(Math.random() * lines.length)];
                this.line = line;
                this.color = line.color;

                const startNodeIndex = Math.floor(Math.random() * line.path.length);
                let endNodeIndex = Math.floor(Math.random() * (line.path.length -1));
                if (endNodeIndex >= startNodeIndex) endNodeIndex++;

                this.path = this.createSubPath(startNodeIndex, endNodeIndex);
                
                this.currentNodeIndex = 0;
                const startStationName = this.path[0];
                this.x = stations[startStationName].x;
                this.y = stations[startStationName].y;

                this.targetX = this.x;
                this.targetY = this.y;

                this.vx = 0;
                this.vy = 0;
                this.speed = PARTICLE_SPEED + Math.random() * 0.5;
                this.setNextTarget();
            }

            createSubPath(startIndex, endIndex) {
                const path = this.line.path;
                if (startIndex < endIndex) {
                    return path.slice(startIndex, endIndex + 1);
                } else {
                    return path.slice(endIndex, startIndex + 1).reverse();
                }
            }
            
            setNextTarget() {
                this.currentNodeIndex++;
                if (this.currentNodeIndex >= this.path.length) {
                    this.reset();
                    return;
                }
                const nextStationName = this.path[this.currentNodeIndex];
                this.targetX = stations[nextStationName].x;
                this.targetY = stations[nextStationName].y;
            }

            update() {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.speed) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.setNextTarget();
                    return;
                }

                this.vx = (dx / dist) * this.speed;
                this.vy = (dy / dist) * this.speed;

                // Mouse interaction
                if (mouse.x && mouse.y) {
                    const mouseDx = this.x - mouse.x;
                    const mouseDy = this.y - mouse.y;
                    const mouseDist = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);

                    if (mouseDist < MOUSE_INFLUENCE_RADIUS) {
                        const force = (MOUSE_INFLUENCE_RADIUS - mouseDist) / MOUSE_INFLUENCE_RADIUS;
                        this.vx += (mouseDx / mouseDist) * force * MOUSE_REPEL_STRENGTH;
                        this.vy += (mouseDy / mouseDist) * force * MOUSE_REPEL_STRENGTH;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        const particles = [];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push(new Particle());
        }

        function animate() {
            // Fading trail effect
            ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
            ctx.fillRect(0, 0, width, height);

            // 1. Draw metro lines
            ctx.lineWidth = 0.5;
            lines.forEach(line => {
                ctx.strokeStyle = line.color + '33'; // Low opacity
                ctx.beginPath();
                const startStation = stations[line.path[0]];
                ctx.moveTo(startStation.x, startStation.y);
                for (let i = 1; i < line.path.length; i++) {
                    const station = stations[line.path[i]];
                    ctx.lineTo(station.x, station.y);
                }
                ctx.stroke();
            });

            // 2. Draw stations
            ctx.fillStyle = '#cccccc';
            Object.values(stations).forEach(station => {
                ctx.beginPath();
                ctx.arc(station.x, station.y, STATION_RADIUS / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // 3. Update and draw particles
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            // Note: In a real-world scenario, you might want to recalculate station positions on resize.
            // For this artistic piece, we'll keep them fixed which works well.
        });

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        
        window.addEventListener('mouseout', () => {
            mouse.x = null;
            mouse.y = null;
        });
        
        // Start the animation
        animate();

    </script>
</body>
</html>
