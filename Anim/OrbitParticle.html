<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mesmerizing Particle Orbits — Interactive Visualization</title>
  <style>
    :root{
      --panel-bg: rgba(255,255,255,0.06);
      --accent: rgba(255,255,255,0.85);
      --glass-border: rgba(255,255,255,0.12);
      --ui-gap: 10px;
      --font: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background: linear-gradient(180deg, #02021a 0%, #0b0f2b 45%, #071426 100%);
      color:var(--accent);
      font-family:var(--font);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }

    /* full-screen canvas layers */
    .stage{position:fixed;inset:0;display:block;}
    canvas{display:block;position:absolute;inset:0;width:100%;height:100%;}

    /* Controls */
    .controls{
      position:fixed;left:18px;top:18px;z-index:40;
      width:320px; padding:14px;border-radius:14px;
      background:var(--panel-bg);border:1px solid var(--glass-border);
      backdrop-filter: blur(8px) saturate(120%);box-shadow:0 8px 20px rgba(2,4,22,0.6);
    }
    .controls h1{margin:0 0 8px 0;font-size:16px;letter-spacing:0.4px}
    .controls p{margin:0 0 10px 0;color:rgba(255,255,255,0.7);font-size:12px}
    .row{display:flex;align-items:center;gap:8px;margin-bottom:8px}
    label{font-size:12px;color:rgba(255,255,255,0.85);width:110px}
    input[type=range]{flex:1}
    .small{font-size:11px;color:rgba(255,255,255,0.6);}
    button{appearance:none;border:0;padding:8px 10px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02));color:var(--accent);cursor:pointer}
    .controls .footer{display:flex;align-items:center;justify-content:space-between;margin-top:8px}

    /* responsive */
    @media (max-width:420px){.controls{width:92%;left:4%;right:4%;}}
  </style>
</head>
<body>
  <div class="stage">
    <canvas id="bg"></canvas>
    <canvas id="main"></canvas>
  </div>

  <div class="controls" aria-label="Visualization controls">
    <div class="row">
      <label for="count">Particles</label>
      <input id="count" type="range" min="80"  step="10" max="1600" value="640">
      <span id="countVal" class="small" style="width:46px;text-align:right">640</span>
    </div>

    <div class="row">
      <label for="speed">Speed</label>
      <input id="speed" type="range" min="0" max="3" step="0.1" value="1">
      <span id="speedVal" class="small" style="width:46px;text-align:right">1.00</span>
    </div>

    <div class="row">
      <label for="trail">Trail</label>
      <input id="trail" type="range" min="0" max="1" step="0.1" value="0.9">
      <span id="trailVal" class="small" style="width:46px;text-align:right">0.9</span>
    </div>

    <div class="footer">
      <div class="small">Click: toggle attraction • Shift+Click: repel</div>
    </div>
  </div>

  <script>
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    const bg = document.getElementById('bg');
    const main = document.getElementById('main');
    const bgCtx = bg.getContext('2d');
    const ctx = main.getContext('2d');

    const stage = {
      w: 0,
      h: 0,
      cx: 0,
      cy: 0
    };

    function resize(){
      stage.w = Math.max(300, window.innerWidth);
      stage.h = Math.max(200, window.innerHeight);
      [bg, main].forEach(c => {
        c.width = Math.floor(stage.w * dpr);
        c.height = Math.floor(stage.h * dpr);
        c.style.width = stage.w + 'px';
        c.style.height = stage.h + 'px';
      });
      bgCtx.setTransform(dpr,0,0,dpr,0,0);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      stage.cx = stage.w / 2; 
      stage.cy = stage.h / 2;
      drawStarfield();
    }
    window.addEventListener('resize', resize);

    const stars = [];
    function initStarfield(){
      stars.length = 0;
      const count = Math.min(500, Math.floor((stage.w * stage.h)/8000));
      for(let i=0;i<count;i++){
        stars.push({
          x: Math.random() * stage.w,
          y: Math.random() * stage.h,
          r: Math.random() * 1.6 + 0.2,
          a: Math.random() * 0.8 + 0.2,
          tw: Math.random() * 0.02 + 0.005
        });
      }
    }
    function drawStarfield(){
      initStarfield();
      bgCtx.clearRect(0,0,stage.w,stage.h);
      const grd = bgCtx.createLinearGradient(0,0,0,stage.h);
      grd.addColorStop(0, 'rgba(6,8,20,0.35)');
      grd.addColorStop(1, 'rgba(2,6,12,0.45)');
      bgCtx.fillStyle = grd;
      bgCtx.fillRect(0,0,stage.w,stage.h);

      for(const s of stars){
        bgCtx.beginPath();
        bgCtx.globalAlpha = s.a;
        bgCtx.fillStyle = 'rgba(255,255,255,0.8)';
        bgCtx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        bgCtx.fill();
      }
      bgCtx.globalAlpha = 1;
      const rg = bgCtx.createRadialGradient(stage.cx, stage.cy, Math.min(stage.w, stage.h)*0.05, stage.cx, stage.cy, Math.min(stage.w, stage.h)*0.9);
      rg.addColorStop(0, 'rgba(12,20,38,0.12)');
      rg.addColorStop(1, 'rgba(2,6,12,0.6)');
      bgCtx.fillStyle = rg;
      bgCtx.fillRect(0,0,stage.w,stage.h);
    }

    class Particle{
      constructor(i, total){
        this.reset(i, total, true);
      }
      reset(i, total, initial = false){
        const ratio = i/total;
        this.orbit = (0.04 + Math.pow(Math.random(), 1.5) * 0.96) * Math.min(stage.w, stage.h) * (0.22 + 0.78*ratio);
        this.angle = Math.random() * Math.PI * 2;
        this.omega = (0.0008 + Math.random()*0.0024) * (Math.random()>0.5?1:-1);
        this.baseSize = 0.9 + Math.random()*2.6;
        this.hueOffset = Math.random()*60 - 30;
        this.alpha = 0.6 + Math.random()*0.4;
        
        // Target calculation
        const tx = stage.cx + Math.cos(this.angle) * this.orbit;
        const ty = stage.cy + Math.sin(this.angle) * this.orbit;
        
        // Spawn exactly at target to prevent initial explosion
        this.x = tx;
        this.y = ty;
        this.vx = 0; 
        this.vy = 0;
      }
      update(dt, t, attractor){
        // Speed scaling should be normalized to around 16ms (60fps)
        const timeFactor = dt / 16.66;
        
        this.angle += this.omega * dt * params.speed * (0.6 + 0.8*Math.sin(t*0.001 + this.hueOffset));
        const breathe = 1 + 0.02*Math.sin(t*0.002 + this.angle*2);
        let tx = stage.cx + Math.cos(this.angle) * this.orbit * breathe;
        let ty = stage.cy + Math.sin(this.angle) * this.orbit * breathe;

        if(attractor.active){
          const ax = attractor.x, ay = attractor.y;
          const dx = ax - this.x, dy = ay - this.y;
          const distSq = dx*dx + dy*dy;
          const dist = Math.sqrt(distSq) || 1;
          
          // Smooth the force to prevent infinite acceleration at dist 0
          const force = (attractor.mode === 'attract' ? 1 : -1) * Math.min(2000/(distSq + 1000), 0.5);
          this.vx += (dx/dist) * force * timeFactor * params.speed;
          this.vy += (dy/dist) * force * timeFactor * params.speed;
        }

        // Tension force
        this.vx += (tx - this.x) * 0.002 * dt;
        this.vy += (ty - this.y) * 0.002 * dt;

        // Friction
        const friction = Math.pow(0.96, timeFactor);
        this.vx *= friction; 
        this.vy *= friction;
        
        this.x += this.vx * timeFactor;
        this.y += this.vy * timeFactor;
      }
      draw(ctx, t){
        const hue = (params.hue + this.hueOffset + 360) % 360;
        const size = this.baseSize * (1 + 0.25*Math.sin(t*0.004 + this.angle*3));
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowBlur = size * 12;
        ctx.shadowColor = `hsl(${hue} 90% 60% / ${0.85})`;
        ctx.fillStyle = `hsl(${hue} 95% 60% / ${this.alpha})`;
        ctx.beginPath(); ctx.arc(this.x, this.y, size, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    const params = {
      count: 640,
      speed: 1.0,
      trail: 0.9,
      hue: 210,
      running: true
    };

    const ui = {
      count: document.getElementById('count'),
      speed: document.getElementById('speed'),
      trail: document.getElementById('trail'),
      countVal: document.getElementById('countVal'),
      speedVal: document.getElementById('speedVal'),
      trailVal: document.getElementById('trailVal')
    };

    const attractor = {active:false, x:0, y:0, mode:'attract'};

    let particles = [];
    function rebuildParticles(){
      const newCount = Math.max(8, Math.min(4000, Math.round(params.count)));
      if(particles.length === 0 || newCount !== particles.length){
        particles = new Array(newCount);
        for(let i=0;i<newCount;i++) particles[i] = new Particle(i, newCount);
      }
    }

    let then = performance.now();
    function frame(now){
      // Cap dt to prevent physics explosions after tab-switching/stutter
      // Use a smaller cap (32ms) to ensure stability
      let dt = Math.min(32, now - then);
      then = now;

      params.hue = (params.hue + dt * 0.02) % 360;

      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = `rgba(3,6,12,${1 - params.trail})`;
      ctx.fillRect(0,0,stage.w,stage.h);

      ctx.globalCompositeOperation = 'lighter';

      for(const p of particles){
        p.update(dt, now, attractor);
        p.draw(ctx, now);
      }

      for(const s of stars){
        s.a += Math.sin(now*0.0007 + s.tw*100) * 0.002;
        s.a = Math.min(1, Math.max(0.12, s.a));
      }

      if(params.running) requestAnimationFrame(frame);
    }

    // FIX: Handle tab switching by resetting the "then" timestamp
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        then = performance.now();
      }
    });

    function onPointerMove(e){
      const rect = main.getBoundingClientRect();
      attractor.x = (e.clientX - rect.left);
      attractor.y = (e.clientY - rect.top);
    }
    function onPointerDown(e){
      attractor.active = true;
      attractor.mode = e.shiftKey ? 'repel' : 'attract';
      onPointerMove(e);
    }
    function onPointerUp(){
      attractor.active = false;
    }

    main.addEventListener('pointermove', onPointerMove);
    main.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointerup', onPointerUp);

    ui.count.addEventListener('input', ()=>{ params.count = +ui.count.value; ui.countVal.textContent = ui.count.value; rebuildParticles(); });
    ui.speed.addEventListener('input', ()=>{ params.speed = +ui.speed.value; ui.speedVal.textContent = (+ui.speed.value).toFixed(2); });
    ui.trail.addEventListener('input', ()=>{ params.trail = +ui.trail.value; ui.trailVal.textContent = (+ui.trail.value).toFixed(3); });

    function init(){
      resize();
      attractor.x = stage.cx;
      attractor.y = stage.cy;
      ui.countVal.textContent = ui.count.value;
      ui.speedVal.textContent = (+ui.speed.value).toFixed(2);
      ui.trailVal.textContent = (+ui.trail.value).toFixed(3);

      params.count = +ui.count.value; 
      params.speed = +ui.speed.value; 
      params.trail = +ui.trail.value; 
      rebuildParticles();

      ctx.fillStyle = 'rgba(3,6,12,1)'; 
      ctx.fillRect(0,0,stage.w,stage.h);
      
      then = performance.now();
      requestAnimationFrame(frame);

      setInterval(()=>{ drawStarfield(); }, 4000);
    }

    init();
  </script>
</body>
</html>