<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Harmonograph</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0a0a10; /* Dark navy background */
            font-family: 'Inter', sans-serif;
            color: white;
            cursor: crosshair;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: none;
            max-width: 250px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="info">
        <b>Move mouse:</b> Influence rotation.<br>
        <b>Drag vertically:</b> Expand/contract rings.<br>
        <b>Click:</b> Create a shockwave.<br>
        <b>Double-click:</b> Warp to a new pattern.
    </div>
    <canvas id="mainCanvas"></canvas>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        let hue = 0;
        let rings = [];
        let stardust = [];
        let shockwaves = [];
        
        let mouseX = width / 2;
        let mouseY = height / 2;
        let isDragging = false;

        let breathTime = 0;
        let shapeMorphTime = 0;
        let warpState = 'none'; // 'none', 'collapsing', 'expanding'
        let warpProgress = 0;

        const config = {
            ringCount: 15,
            baseRadius: 20,
            radiusIncrement: 25,
            shapesPerRing: 20,
            shapeSize: 5,
            baseRotationSpeed: 0.001,
            particleCount: 20,
        };
        const baseRadiusIncrement = config.radiusIncrement;

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = width / 2;
                this.y = height / 2;
                this.size = Math.random() * 1.5 + 0.5;
                this.speed = Math.random() * 0.6 + 0.3;
                this.alpha = Math.random() * 0.6 + 0.4;
                const moveAngle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(moveAngle) * this.speed;
                this.vy = Math.sin(moveAngle) * this.speed;
            }

            update(shapes) {
                this.x += this.vx;
                this.y += this.vy;

                // --- MODIFIED --- Changed physics from bounce to deflection
                for (const shapePos of shapes) {
                    const dx = this.x - shapePos.x;
                    const dy = this.y - shapePos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const collisionDist = config.shapeSize * 2.5; // Collision radius

                    if (dist < collisionDist) {
                        // Nudge the particle instead of a hard bounce
                        const normalX = dx / dist;
                        const normalY = dy / dist;
                        
                        // Add a gentle push away from the shape's center
                        const nudgeStrength = 0.01; 
                        this.vx += normalX * nudgeStrength;
                        this.vy += normalY * nudgeStrength;

                        // Re-normalize speed to prevent particles from accelerating indefinitely
                        const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                        if (currentSpeed > this.speed * 1.5) { // Cap the speed
                            this.vx = (this.vx / currentSpeed) * this.speed;
                            this.vy = (this.vy / currentSpeed) * this.speed;
                        }
                        
                        break; // Only handle one collision per frame for performance
                    }
                }


                const travelDist = Math.sqrt(Math.pow(this.x - width / 2, 2) + Math.pow(this.y - height / 2, 2));
                if (travelDist > Math.max(width, height) / 1.8) {
                    this.reset();
                }
            }

            draw() {
                const particleHue = (hue + this.x * 0.2) % 360;
                const saturation = 25;
                const lightness = 90;
                ctx.fillStyle = `hsla(${particleHue}, ${saturation}%, ${lightness}%, ${this.alpha})`;

                const centerX = width / 2;
                const centerY = height / 2;
                const dx = this.x - centerX;
                const dy = this.y - centerY;

                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.arc(dx, dy, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(dx, -dy, this.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }
        }

        class Shockwave {
            constructor() {
                this.radius = 0;
                this.maxRadius = Math.sqrt(Math.pow(width / 2, 2) + Math.pow(height / 2, 2));
                this.speed = 5; 
                this.alpha = 1;
                this.hue = hue;
            }

            update() {
                this.radius += this.speed;
                this.alpha = Math.max(0, 1 - (this.radius / this.maxRadius));

                stardust.forEach(p => {
                    const dx = p.x - width / 2;
                    const dy = p.y - height / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > this.radius - 20 && dist < this.radius + 20) {
                        const angle = Math.atan2(dy, dx);
                        p.vx += Math.cos(angle) * this.alpha * 4;
                        p.vy += Math.sin(angle) * this.alpha * 4;
                    }
                });
            }

            draw() {
                if (this.alpha <= 0) return;
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.strokeStyle = `hsla(${this.hue}, 100%, 70%, ${this.alpha * 0.8})`;
                ctx.lineWidth = 1 + this.alpha * 4;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        class Ring {
            constructor(radius, shapeCount, rotationSpeed) {
                this.baseRadius = radius;
                this.radius = radius;
                this.shapeCount = shapeCount;
                this.rotationSpeed = rotationSpeed;
                this.angle = Math.random() * Math.PI * 2;
            }

            update(mouseInfluence) {
                this.angle += this.rotationSpeed * mouseInfluence;
            }

            // --- NEW METHOD --- Calculates absolute screen positions of each shape
            getShapePositions() {
                const positions = [];
                const breathFactor = Math.sin(breathTime + this.baseRadius * 0.05) * 5;
                const displayRadius = this.radius + breathFactor;
                const warpScale = (warpState === 'collapsing') ? (1-warpProgress) : (warpState === 'expanding' ? warpProgress : 1);
                
                const cosRingAngle = Math.cos(this.angle);
                const sinRingAngle = Math.sin(this.angle);

                for (let i = 0; i < this.shapeCount; i++) {
                    const angleStep = (Math.PI * 2) / this.shapeCount;
                    const currentAngle = i * angleStep;
                    
                    const localX = Math.cos(currentAngle) * displayRadius * warpScale;
                    const localY = Math.sin(currentAngle) * displayRadius * warpScale;
                    
                    const rotatedX = localX * cosRingAngle - localY * sinRingAngle;
                    const rotatedY = localX * sinRingAngle + localY * cosRingAngle;

                    positions.push({ x: width / 2 + rotatedX, y: height / 2 + rotatedY });
                }
                return positions;
            }

            draw() {
                const breathFactor = Math.sin(breathTime + this.baseRadius * 0.05) * 5;
                const displayRadius = this.radius + breathFactor;
                const warpScale = (warpState === 'collapsing') ? (1-warpProgress) : (warpState === 'expanding' ? warpProgress : 1);

                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(this.angle);

                for (let i = 0; i < this.shapeCount; i++) {
                    const angleStep = (Math.PI * 2) / this.shapeCount;
                    const currentAngle = i * angleStep;
                    
                    const x = Math.cos(currentAngle) * displayRadius * warpScale;
                    const y = Math.sin(currentAngle) * displayRadius * warpScale;
                    
                    const colorHue = (hue + this.radius * 0.5) % 360;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(-this.angle * 2.5 + currentAngle);

                    const morph = (Math.sin(shapeMorphTime + this.baseRadius * 0.02) + 1) / 2;
                    const size = config.shapeSize;

                    ctx.beginPath();
                    const h1 = size * 1.5 - (size * 0.5 * morph);
                    const h2 = size * 1.5 - (size * 0.5 * (1-morph));
                    ctx.moveTo(0, -h1);
                    ctx.lineTo(-size, 0);
                    ctx.lineTo(0, h2);
                    ctx.lineTo(size, 0);
                    ctx.closePath();
                    
                    ctx.fillStyle = `hsl(${colorHue}, 100%, 65%)`;
                    ctx.strokeStyle = `hsl(${colorHue}, 100%, 80%)`;
                    ctx.lineWidth = 1;
                    
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.restore();
            }
        }

        function init() {
            rings = [];
            stardust = [];
            shockwaves = [];
            for (let i = 0; i < config.ringCount; i++) {
                const radius = config.baseRadius + i * baseRadiusIncrement;
                const speed = (config.baseRotationSpeed * (config.ringCount - i)) / 2;
                const direction = i % 2 === 0 ? 1 : -1;
                rings.push(new Ring(radius, config.shapesPerRing + i * 2, speed * direction));
            }
            for (let i = 0; i < config.particleCount; i++) {
                stardust.push(new Particle());
            }
        }

        function handleWarpJump() {
            if (warpState === 'collapsing') {
                warpProgress += 0.05;
                if (warpProgress >= 1) {
                    warpProgress = 1;
                    init();
                    warpState = 'expanding';
                }
            } else if (warpState === 'expanding') {
                warpProgress -= 0.05;
                if (warpProgress <= 0) {
                    warpProgress = 0;
                    warpState = 'none';
                }
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 16, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // --- MODIFIED --- Calculate all shape positions once per frame for efficiency
            const allShapePositions = [];
            rings.forEach(ring => {
                allShapePositions.push(...ring.getShapePositions());
            });

            stardust.forEach(p => {
                p.update(allShapePositions); // Pass shape positions to particle update
                p.draw();
            });

            if (warpState !== 'none') {
                handleWarpJump();
            } else {
                if (isDragging) {
                    const dragFactor = Math.max(0.2, 1 + (mouseY - height / 2) / (height / 2) * 2);
                    rings.forEach((ring) => {
                        const newRadius = ring.baseRadius * dragFactor;
                        ring.radius += (newRadius - ring.radius) * 0.1;
                    });
                } else {
                     rings.forEach((ring) => {
                        ring.radius += (ring.baseRadius - ring.radius) * 0.05;
                    });
                }
            }

            const mouseInfluence = 1 + (mouseX - width / 2) / (width / 2) * 1.5;

            rings.forEach(ring => {
                ring.update(mouseInfluence);
                ring.draw();
            });

            for (let i = shockwaves.length - 1; i >= 0; i--) {
                shockwaves[i].update();
                shockwaves[i].draw();
                if (shockwaves[i].alpha <= 0) {
                    shockwaves.splice(i, 1);
                }
            }

            hue += 0.2;
            breathTime += 0.01;
            shapeMorphTime += 0.005;

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            init();
        });
        
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        window.addEventListener('mousedown', () => { isDragging = true; });
        window.addEventListener('mouseup', () => { isDragging = false; });
        window.addEventListener('click', () => { shockwaves.push(new Shockwave()); });

        window.addEventListener('dblclick', (e) => {
            e.preventDefault(); 
            if (warpState === 'none') {
                warpState = 'collapsing';
                warpProgress = 0;
            }
        });

        init();
        animate();
    </script>
</body>
</html>
