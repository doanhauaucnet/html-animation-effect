<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tokyo Metro Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #0a0a0a;
        color: #f0f0f0;
        overflow: hidden;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }
      .ui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
      }
      .station-label {
        position: absolute;
        transform: translate(-50%, -100%) scale(0);
        transform-origin: bottom center;
        font-weight: 600;
        font-size: 16px;
        white-space: nowrap;
        pointer-events: none;
        transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
    </style>
  </head>
  <body>
    <canvas id="particleCanvas"></canvas>

    <div class="ui-container">
      <div class="text-center bg-black/30 backdrop-blur-sm p-4 rounded-lg">
        <h1 class="text-2xl md:text-4xl font-bold text-white tracking-wider">
          Tokyo Metro Data Stream
        </h1>
      </div>
      <div id="labelsContainer"></div>
    </div>

    <script>
      const canvas = document.getElementById("particleCanvas");
      const ctx = canvas.getContext("2d");
      let width = (canvas.width = window.innerWidth);
      let height = (canvas.height = window.innerHeight);

      // --- Configuration ---
      const PARTICLE_COUNT = 200;
      const PARTICLE_SPEED = 0.8;
      const STATION_RADIUS = 5;
      const MOUSE_INFLUENCE_RADIUS = 150;
      const MOUSE_REPEL_STRENGTH = 2;
      const LABEL_HOVER_RADIUS = 120;

      let mouse = { x: null, y: null };
      let slowMode = false;
      let fastMode = false;
      let slowTimeout = null;
      let fastTimeout = null;

      // --- Metro Data ---
      const stations = {
        Shibuya: { x: width * 0.25, y: height * 0.8 },
        Shinjuku: { x: width * 0.2, y: height * 0.5 },
        Ikebukuro: { x: width * 0.35, y: height * 0.2 },
        Ueno: { x: width * 0.75, y: height * 0.2 },
        Tokyo: { x: width * 0.65, y: height * 0.6 },
        Ginza: { x: width * 0.55, y: height * 0.7 },
        Akasaka: { x: width * 0.4, y: height * 0.65 },
        Otemachi: { x: width * 0.6, y: height * 0.5 },
        Korakuen: { x: width * 0.5, y: height * 0.35 },
        Roppongi: { x: width * 0.4, y: height * 0.8 },
        Nakano: { x: width * 0.05, y: height * 0.45 },
        Kitasenju: { x: width * 0.9, y: height * 0.1 },
        Akihabara: { x: width * 0.7, y: height * 0.25 },
        Asakusa: { x: width * 0.85, y: height * 0.35 },
        Shinagawa: { x: width * 0.55, y: height * 0.9 },
        Meguro: { x: width * 0.15, y: height * 0.85 },
      };

      const lines = [
        {
          color: "#ff9500",
          path: ["Shibuya", "Akasaka", "Ginza", "Tokyo", "Ueno"],
        },
        {
          color: "#f62e36",
          path: [
            "Ikebukuro",
            "Korakuen",
            "Otemachi",
            "Tokyo",
            "Ginza",
            "Akasaka",
            "Shinjuku",
          ],
        },
        {
          color: "#009b48",
          path: ["Shibuya", "Akasaka", "Otemachi", "Kitasenju"],
        },
        {
          color: "#0078ba",
          path: ["Nakano", "Shinjuku", "Otemachi", "Tokyo", "Akihabara"],
        },
        {
          color: "#a0a2a1",
          path: ["Roppongi", "Shinjuku", "Ueno", "Kitasenju"],
        },
        {
          color: "#8e5e98",
          path: ["Shibuya", "Otemachi", "Kitasenju", "Asakusa"],
        },
        { color: "#ffcc00", path: ["Shinagawa", "Meguro", "Shibuya"] },
        { color: "#00cccc", path: ["Tokyo", "Akihabara", "Asakusa"] },
      ];

      const stationColors = {};
      for (const line of lines) {
        for (const station of line.path) {
          if (!stationColors[station]) stationColors[station] = line.color;
        }
      }

      // --- Particle Class ---
      class Particle {
        constructor() {
          this.reset();
        }
        reset() {
          const line = lines[Math.floor(Math.random() * lines.length)];
          this.line = line;
          this.color = line.color;
          const startNodeIndex = Math.floor(Math.random() * line.path.length);
          let endNodeIndex = Math.floor(Math.random() * (line.path.length - 1));
          if (endNodeIndex >= startNodeIndex) endNodeIndex++;
          this.path = this.createSubPath(startNodeIndex, endNodeIndex);
          this.currentNodeIndex = 0;
          const startStation = this.path[0];
          this.x = stations[startStation].x;
          this.y = stations[startStation].y;
          this.targetX = this.x;
          this.targetY = this.y;
          this.vx = 0;
          this.vy = 0;
          this.speed = PARTICLE_SPEED + Math.random() * 0.5;
          this.setNextTarget();
        }
        createSubPath(s, e) {
          const p = this.line.path;
          return s < e ? p.slice(s, e + 1) : p.slice(e, s + 1).reverse();
        }
        setNextTarget() {
          this.currentNodeIndex++;
          if (this.currentNodeIndex >= this.path.length) {
            this.reset();
            return;
          }
          const next = this.path[this.currentNodeIndex];
          this.targetX = stations[next].x;
          this.targetY = stations[next].y;
        }
        update() {
          const dx = this.targetX - this.x,
            dy = this.targetY - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < this.speed) {
            this.x = this.targetX;
            this.y = this.targetY;
            this.setNextTarget();
            return;
          }

          let currentSpeed = this.speed;
          if (slowMode) {
            currentSpeed *= 0.1;
          } else if (fastMode) {
            currentSpeed *= 3;
          }

          this.vx = (dx / dist) * currentSpeed;
          this.vy = (dy / dist) * currentSpeed;

          if (mouse.x && mouse.y) {
            const mdx = this.x - mouse.x,
              mdy = this.y - mouse.y;
            const mdist = Math.sqrt(mdx * mdx + mdy * mdy);
            if (mdist < MOUSE_INFLUENCE_RADIUS) {
              const force =
                (MOUSE_INFLUENCE_RADIUS - mdist) / MOUSE_INFLUENCE_RADIUS;
              this.vx += (mdx / mdist) * force * MOUSE_REPEL_STRENGTH;
              this.vy += (mdy / mdist) * force * MOUSE_REPEL_STRENGTH;
            }
          }

          this.x += this.vx;
          this.y += this.vy;
        }
        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }
      }

      const particles = [];
      for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(new Particle());

      // --- Station Labels ---
      const labelsContainer = document.getElementById("labelsContainer");
      const stationLabels = {};
      Object.keys(stations).forEach((name) => {
        const div = document.createElement("div");
        div.className = "station-label";
        div.textContent = name;
        div.style.color = stationColors[name] || "#fff";
        labelsContainer.appendChild(div);
        stationLabels[name] = div;
      });

      // --- Animation Loop ---
      function animate() {
        ctx.fillStyle = "rgba(10,10,10,0.2)";
        ctx.fillRect(0, 0, width, height);

        // Draw lines
        ctx.lineWidth = 0.5;
        lines.forEach((line) => {
          ctx.strokeStyle = line.color + "33";
          ctx.beginPath();
          const start = stations[line.path[0]];
          ctx.moveTo(start.x, start.y);
          for (let i = 1; i < line.path.length; i++) {
            const st = stations[line.path[i]];
            ctx.lineTo(st.x, st.y);
          }
          ctx.stroke();
        });

        // Draw stations
        ctx.fillStyle = "#cccccc";
        Object.values(stations).forEach((st) => {
          ctx.beginPath();
          ctx.arc(st.x, st.y, STATION_RADIUS / 2, 0, Math.PI * 2);
          ctx.fill();
        });

        // Update particles
        particles.forEach((p) => {
          p.update();
          p.draw();
        });

        // Update labels
        Object.entries(stations).forEach(([name, pos]) => {
          const label = stationLabels[name];
          if (slowMode || fastMode) {
            label.style.transform = "translate(-50%, -100%) scale(1)";
          } else {
            if (mouse.x !== null && mouse.y !== null) {
              const dx = mouse.x - pos.x,
                dy = mouse.y - pos.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < LABEL_HOVER_RADIUS) {
                const scale = 1 + 0.5 * (1 - dist / LABEL_HOVER_RADIUS);
                label.style.transform = `translate(-50%, -100%) scale(${scale})`;
              } else {
                label.style.transform = "translate(-50%, -100%) scale(0)";
              }
            } else {
              label.style.transform = "translate(-50%, -100%) scale(0)";
            }
          }
          label.style.left = pos.x + "px";
          label.style.top = pos.y + "px";
        });

        requestAnimationFrame(animate);
      }

      // --- Events ---
      window.addEventListener("resize", () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      });

      window.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      window.addEventListener("mouseout", () => {
        mouse.x = null;
        mouse.y = null;
      });

      window.addEventListener("click", (e) => {
        if (e.button === 0) {
          // Cancel fast mode if active
          if (fastTimeout) clearTimeout(fastTimeout);
          fastMode = false;

          // Activate slow mode
          slowMode = true;
          Object.values(stationLabels).forEach((label) => {
            label.style.transform = "translate(-50%, -100%) scale(1)";
          });

          if (slowTimeout) clearTimeout(slowTimeout);
          slowTimeout = setTimeout(() => {
            slowMode = false;
          }, 5000);
        }
      });

      window.addEventListener("contextmenu", (e) => {
        e.preventDefault(); // prevent browser context menu

        if (slowTimeout) clearTimeout(slowTimeout);
        slowMode = false;

        // Activate fast mode
        fastMode = true;
        Object.values(stationLabels).forEach((label) => {
          label.style.transform = "translate(-50%, -100%) scale(1)";
        });

        if (fastTimeout) clearTimeout(fastTimeout);
        fastTimeout = setTimeout(() => {
          fastMode = false;
        }, 5000);
      });

      animate();
    </script>
  </body>
</html>
