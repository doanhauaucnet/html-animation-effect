<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Realistic Snowflakes â€” Visualization</title>
  <style>
    :root {
      --bg-top: #07102a;
      --bg-mid: #0b1b3a;
      --bg-bottom: #081024;
      --accent: #d0f0ff;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 600px at 10% 20%, rgba(255, 255, 255, 0.02), transparent),
        linear-gradient(180deg, var(--bg-top) 0%, var(--bg-mid) 60%, var(--bg-bottom) 100%);
      color: var(--accent);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
    }

    #container {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <div id="container">
    <canvas id="c"></canvas>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha: true });

      function resize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.round(window.innerWidth * dpr);
        canvas.height = Math.round(window.innerHeight * dpr);
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        width = window.innerWidth;
        height = window.innerHeight;
      }

      let width = window.innerWidth;
      let height = window.innerHeight;
      resize();
      window.addEventListener('resize', () => {
        resize();
        initSnowflakes();
      });

      const LAYER_COUNT = 3;
      const SNOW_COUNTS = [40, 80, 150];
      const LAYER_SPEED = [0.6, 0.4, 0.2];
      const LAYER_SIZE_RANGE = [[6, 12], [4, 8], [2, 4]];
      const ROTATION_SPEED = [[0.01, 0.03], [0.008, 0.02], [0.005, 0.015]];
      const WIND_SWAY = [0.6, 0.9, 1.3];

      let layers = [];

      function rand(min, max) { return Math.random() * (max - min) + min; }

      function initSnowflakes() {
        layers = [];
        for (let i = 0; i < LAYER_COUNT; i++) {
          const flakes = [];
          const count = Math.round((SNOW_COUNTS[i] || 100) * (Math.max(width, height) / 1000));
          for (let s = 0; s < count; s++) {
            flakes.push(makeFlake(i));
          }
          layers.push(flakes);
        }
      }

      function makeFlake(layerIndex) {
        const sizeRange = LAYER_SIZE_RANGE[layerIndex];
        const size = rand(sizeRange[0], sizeRange[1]);
        const x = rand(0, width);
        const y = rand(-height, height);
        const speed = LAYER_SPEED[layerIndex] * rand(0.8, 1.2);
        const swayPhase = rand(0, Math.PI * 2);
        const rotation = rand(0, Math.PI * 2);
        const rotationSpeed = rand(ROTATION_SPEED[layerIndex][0], ROTATION_SPEED[layerIndex][1]) * (Math.random() < 0.5 ? -1 : 1);
        const tiltSpeed = rand(0.01, 0.03) * (Math.random() < 0.5 ? -1 : 1);
        const tilt = rand(0, Math.PI * 2);
        return { x, y, size, speed, swayPhase, rotation, rotationSpeed, tilt, tiltSpeed };
      }

      let last = performance.now();

      function step(now) {
        const dt = Math.min(33, now - last);
        last = now;

        update(dt);
        render();

        requestAnimationFrame(step);
      }

      function update(dt) {
        for (let li = 0; li < layers.length; li++) {
          const layer = layers[li];
          const sway = WIND_SWAY[li];
          for (let s = 0; s < layer.length; s++) {
            const fl = layer[s];
            fl.y += fl.speed * (dt / 16.67);
            fl.swayPhase += 0.003 * (dt / 16.67);
            fl.x += Math.sin(fl.swayPhase + s * 0.01) * (sway * 0.12) * (dt / 16.67);
            fl.rotation += fl.rotationSpeed * (dt / 16.67);
            fl.tilt += fl.tiltSpeed * (dt / 16.67);
            if (fl.y > height + 50 || fl.x < -100 || fl.x > width + 100) {
              fl.x = rand(-100, width + 100);
              fl.y = rand(-500, -10); // start higher above screen
              fl.speed = LAYER_SPEED[li] * rand(0.8, 1.2);
            }
          }
        }
      }

      function render() {
        ctx.clearRect(0, 0, width, height);

        ctx.save();
        const vg = ctx.createRadialGradient(width * 0.5, height * 0.3, Math.min(width, height) * 0.2, width * 0.5, height * 0.5, Math.max(width, height));
        vg.addColorStop(0, 'rgba(255,255,255,0.00)');
        vg.addColorStop(0.5, 'rgba(4,8,20,0.08)');
        vg.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = vg;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();

        for (let li = layers.length - 1; li >= 0; li--) {
          const layer = layers[li];
          for (let i = 0; i < layer.length; i++) {
            drawFlake(layer[i]);
          }
        }
      }

      function drawFlake(fl) {
        ctx.save();
        ctx.translate(fl.x, fl.y);
        ctx.rotate(fl.rotation);
        const scale = 0.5 + 0.5 * Math.sin(fl.tilt);
        ctx.scale(scale, scale);
        ctx.strokeStyle = `rgba(180, 230, 255, 0.9)`; // icy blue
        ctx.lineWidth = Math.max(1, fl.size * 0.06);

        // Draw 6 main arms
        for (let i = 0; i < 6; i++) {
          ctx.save();
          ctx.rotate(i * Math.PI / 3);
          drawBranch(fl.size);
          ctx.restore();
        }

        ctx.restore();
      }

      // Draw a single branch with smaller sub-branches
      function drawBranch(length) {
        const branchCount = 2; // number of smaller branches on each side
        const subLength = length * 0.3;

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, length);
        ctx.stroke();

        for (let i = 1; i <= branchCount; i++) {
          const pos = (length / (branchCount + 1)) * i;

          // left side
          ctx.beginPath();
          ctx.moveTo(0, pos);
          ctx.lineTo(-subLength / 2, pos + subLength);
          ctx.stroke();

          // right side
          ctx.beginPath();
          ctx.moveTo(0, pos);
          ctx.lineTo(subLength / 2, pos + subLength);
          ctx.stroke();
        }
      }

      initSnowflakes();
      requestAnimationFrame(step);

    })();
  </script>
</body>

</html>