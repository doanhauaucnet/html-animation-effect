<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Realistic Snowflakes 3D</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: radial-gradient(1200px 600px at 10% 20%, rgba(255,255,255,0.02), transparent),
                linear-gradient(180deg, #07102a 0%, #0b1b3a 60%, #081024 100%);
    font-family: Inter, sans-serif;
  }

  canvas { display: block; width:100vw; height:100vh; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let width = window.innerWidth;
let height = window.innerHeight;

function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

// Layers and parameters
const LAYER_COUNT = 3;
const SNOW_COUNTS = [40, 80, 150];
const LAYER_SPEED = [0.6, 0.4, 0.2];
const LAYER_SIZE_RANGE = [[2,4],[3,6],[5,10]];
const ROTATION_SPEED = [[0.01,0.03],[0.008,0.02],[0.005,0.015]];
const WIND_SWAY = [0.6,0.9,1.3];

// Lifespan control
const SNOW_MIN_LIFESPAN = 300;
const SNOW_MAX_LIFESPAN = 800;

let layers = [];
let initialSpawn = true; // flag for initial spawn

function rand(min,max){ return Math.random()*(max-min)+min; }

function initSnowflakes(){
  layers = [];
  for(let i=0;i<LAYER_COUNT;i++){
    const flakes=[];
    const count = SNOW_COUNTS[i];
    for(let s=0;s<count;s++){
      flakes.push(makeFlake(i, true));
    }
    layers.push(flakes);
  }
  initialSpawn = false; // next spawns use top-half preference
}

// Create snowflake
function makeFlake(layerIndex, spawnTop=false){
  const sizeRange = LAYER_SIZE_RANGE[layerIndex];

  // Spawn size: smaller for top-half flakes but not tiny
  const targetSize = spawnTop 
    ? rand(sizeRange[0]*0.6, sizeRange[1]*0.8) 
    : rand(sizeRange[0], sizeRange[1]);
  const size = targetSize * 0.4; // start smaller, will grow

  let x = rand(0,width);
  let y;
  if(initialSpawn){
    y = rand(0,height);
  } else {
    y = Math.random() < 0.8 ? rand(-50, height/2) : rand(-50, height);
  }

  const speed = LAYER_SPEED[layerIndex] * rand(0.8,1.2);
  const swayPhase = rand(0,Math.PI*2);
  const rotation = rand(0,Math.PI*2);
  const rotationSpeed = rand(ROTATION_SPEED[layerIndex][0], ROTATION_SPEED[layerIndex][1]) * (Math.random()<0.5?-1:1);
  const tilt = rand(0,Math.PI*2);
  const tiltSpeed = rand(0.01,0.03) * (Math.random()<0.5?-1:1);
  const lifespan = rand(SNOW_MIN_LIFESPAN,SNOW_MAX_LIFESPAN);
  const alpha = 0; // fade in

  return {x,y,size,targetSize,speed,swayPhase,rotation,rotationSpeed,tilt,tiltSpeed,lifespan,startY:y,alpha};
}

// Update snowflakes
let last = performance.now();
function step(now){
  const dt = Math.min(33, now-last);
  last = now;
  update(dt);
  render();
  requestAnimationFrame(step);
}

function update(dt){
  for(let li=0;li<layers.length;li++){
    const layer = layers[li];
    const sway = WIND_SWAY[li];
    for(let s=0;s<layer.length;s++){
      const fl = layer[s];

      // Movement
      fl.y += fl.speed * (dt/16.67);
      fl.swayPhase += 0.003*(dt/16.67);
      fl.x += Math.sin(fl.swayPhase + s*0.01)*(sway*0.12)*(dt/16.67);
      fl.rotation += fl.rotationSpeed*(dt/16.67);
      fl.tilt += fl.tiltSpeed*(dt/16.67);

      // Fade in
      if(fl.alpha < 1){
        fl.alpha += 0.01*(dt/16.67);
        if(fl.alpha>1) fl.alpha=1;
      }

      // Gradually grow to target size
      if(fl.size < fl.targetSize){
        fl.size += 0.02*(dt/16.67);
        if(fl.size > fl.targetSize) fl.size = fl.targetSize;
      }

      // Random shrink some flakes
      if(Math.random()<0.002){
        fl.size *= rand(0.92,0.98);
      }

      // Fade out if too small or off canvas
      if(fl.size<0.5 || fl.y>height+50 || fl.x<-100 || fl.x>width+100){
        fl.alpha -= 0.03*(dt/16.67);
        if(fl.alpha<=0){
          Object.assign(fl, makeFlake(li,true));
        }
      }
    }
  }
}

// Draw
function render(){
  ctx.clearRect(0,0,width,height);

  // Background gradient
  const vg = ctx.createRadialGradient(width*0.5,height*0.3,Math.min(width,height)*0.2,width*0.5,height*0.5,Math.max(width,height));
  vg.addColorStop(0,'rgba(255,255,255,0.00)');
  vg.addColorStop(0.5,'rgba(4,8,20,0.08)');
  vg.addColorStop(1,'rgba(0,0,0,0.6)');
  ctx.fillStyle=vg;
  ctx.fillRect(0,0,width,height);

  // Draw flakes
  for(let li=layers.length-1;li>=0;li--){
    const layer = layers[li];
    for(let i=0;i<layer.length;i++){
      drawFlake(layer[i]);
    }
  }
}

function drawFlake(fl){
  ctx.save();
  ctx.translate(fl.x, fl.y);
  ctx.rotate(fl.rotation);
  ctx.globalAlpha = fl.alpha;
  ctx.strokeStyle = `rgba(180,230,255,${fl.alpha})`;
  ctx.lineWidth = Math.min(3, Math.max(1, fl.size*0.05));

  const armLength = Math.min(fl.size,10);

  for(let i=0;i<6;i++){
    ctx.save();
    ctx.rotate(i*Math.PI/3);
    drawBranch(armLength);
    ctx.restore();
  }

  ctx.restore();
}

function drawBranch(length){
  const branchCount=2;
  const subLength=length*0.3;

  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(0,length);
  ctx.stroke();

  for(let i=1;i<=branchCount;i++){
    const pos = (length/(branchCount+1))*i;
    ctx.beginPath();
    ctx.moveTo(0,pos);
    ctx.lineTo(-subLength/2,pos+subLength);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,pos);
    ctx.lineTo(subLength/2,pos+subLength);
    ctx.stroke();
  }
}

initSnowflakes();
requestAnimationFrame(step);
})();
</script>
</body>
</html>
